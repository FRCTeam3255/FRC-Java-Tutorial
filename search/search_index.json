{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Introductions # The unofficial FIRST Robotics Competition Java Programming Tutorial. Info Updated for the 2021 Season Last updated: 9/30/21 Disclaimer: Some screenshots may have different colors, icons, more/less folders/files than you due to themes or personal settings. This is normal and should not impact the tutorial. If you still have any questions please contact us. Powered by # Contributors # Name Team Team Role Tayler Uva 3255 Coach Isaac Sayasane 3255 Alumni Sharon Riggs 6995 Mentor","title":"Introductions"},{"location":"index.html#introductions","text":"The unofficial FIRST Robotics Competition Java Programming Tutorial. Info Updated for the 2021 Season Last updated: 9/30/21 Disclaimer: Some screenshots may have different colors, icons, more/less folders/files than you due to themes or personal settings. This is normal and should not impact the tutorial. If you still have any questions please contact us.","title":"Introductions"},{"location":"index.html#powered-by","text":"","title":"Powered by"},{"location":"index.html#contributors","text":"Name Team Team Role Tayler Uva 3255 Coach Isaac Sayasane 3255 Alumni Sharon Riggs 6995 Mentor","title":"Contributors"},{"location":"contributing.html","text":"Contributing # Helping out with the project! Example Project Code # If you make Example Project Code changes please contribute changes that reflect this in the Documentation. This will make it easier for us and more likely that your contribution will be approved. Documentation # If you make documentation changes please contribute changes that reflect this in the Example Project Code. This will make it easier for us and more likely that your contribution will be approved. There are a couple of ways to contribute to this project: Via the web Via local source Via the web # Editing Pages # On each page there is an option to edit the page. Any changes you make through this option will be submitted and become live once they are approved. The edit icon looks like this: Alternatively you could create a pull request and clone the repository New Pages # You can help the project by making new pages. Any pages you make will become live once they are approved. Click here to create a new page Please use the New Page Template Click here to see tips on creating markdown documents Warning Make sure all documentation files end in .md Tip You can add to a certain tab by appending /tab_name/ to the file name Tip Visit Admonitions (call-out) references for a list off call-outs like this one. Via local source # Prerequisites # Install GitHub Desktop (Beginner) or Install Git (Expert) Install Python Install pip requirements Run one of the following commands. Try each one in order until successful. pip install -r requirements.txt python -m pip install -r requirements.txt py -m pip install -r requirements.txt Creating local edits # Visit https://github.com/FRCTeam3255/FRC-Java-Tutorial/tree/main/ and fork the repository. Clone your the newly created fork to your machine and open it Run the command mkdocs serve to open up a live local version of the project in your browser If mkdocs serve does not work on its own, try each one in order until successful: python -m mkdocs serve py -m mkdocs serve Make your changes or additions in the docs directory. Please maintain the organizational folder structure. If added a new page, add the relative url to the mkdocs.yml file in the # Navigation ( nav: ) section. For new pages please use the New Page Template Click here to see tips on creating markdown documents Pushing your local edits to the web # Commit your changes Push your changes to GitHub Back on the webpage for your fork of the project select Pull Request Create a new pull request Wait for the pull request to be approved. New Page Template # Please copy this code as a template to create your new page # Page title <!-- This page was contributed by: --> Subtitle <!-- Add a page image to make it pretty! --> ![Image Title](imageURL) ## Overview This section will help you learn to BLANK. **See table of contents for a breakdown of this section.** *** ## Section One - Some info - Some other into - Some sub info ### Section One Subsection *** ## Section Two - Info - Info 2 !!! Tip This is a tip.","title":"Contributing"},{"location":"contributing.html#contributing","text":"Helping out with the project!","title":"Contributing"},{"location":"contributing.html#example-project-code","text":"If you make Example Project Code changes please contribute changes that reflect this in the Documentation. This will make it easier for us and more likely that your contribution will be approved.","title":"Example Project Code"},{"location":"contributing.html#documentation","text":"If you make documentation changes please contribute changes that reflect this in the Example Project Code. This will make it easier for us and more likely that your contribution will be approved. There are a couple of ways to contribute to this project: Via the web Via local source","title":"Documentation"},{"location":"contributing.html#via-the-web","text":"","title":"Via the web"},{"location":"contributing.html#editing-pages","text":"On each page there is an option to edit the page. Any changes you make through this option will be submitted and become live once they are approved. The edit icon looks like this: Alternatively you could create a pull request and clone the repository","title":"Editing Pages"},{"location":"contributing.html#new-pages","text":"You can help the project by making new pages. Any pages you make will become live once they are approved. Click here to create a new page Please use the New Page Template Click here to see tips on creating markdown documents Warning Make sure all documentation files end in .md Tip You can add to a certain tab by appending /tab_name/ to the file name Tip Visit Admonitions (call-out) references for a list off call-outs like this one.","title":"New Pages"},{"location":"contributing.html#via-local-source","text":"","title":"Via local source"},{"location":"contributing.html#prerequisites","text":"Install GitHub Desktop (Beginner) or Install Git (Expert) Install Python Install pip requirements Run one of the following commands. Try each one in order until successful. pip install -r requirements.txt python -m pip install -r requirements.txt py -m pip install -r requirements.txt","title":"Prerequisites"},{"location":"contributing.html#creating-local-edits","text":"Visit https://github.com/FRCTeam3255/FRC-Java-Tutorial/tree/main/ and fork the repository. Clone your the newly created fork to your machine and open it Run the command mkdocs serve to open up a live local version of the project in your browser If mkdocs serve does not work on its own, try each one in order until successful: python -m mkdocs serve py -m mkdocs serve Make your changes or additions in the docs directory. Please maintain the organizational folder structure. If added a new page, add the relative url to the mkdocs.yml file in the # Navigation ( nav: ) section. For new pages please use the New Page Template Click here to see tips on creating markdown documents","title":"Creating local edits"},{"location":"contributing.html#pushing-your-local-edits-to-the-web","text":"Commit your changes Push your changes to GitHub Back on the webpage for your fork of the project select Pull Request Create a new pull request Wait for the pull request to be approved.","title":"Pushing your local edits to the web"},{"location":"contributing.html#new-page-template","text":"Please copy this code as a template to create your new page # Page title <!-- This page was contributed by: --> Subtitle <!-- Add a page image to make it pretty! --> ![Image Title](imageURL) ## Overview This section will help you learn to BLANK. **See table of contents for a breakdown of this section.** *** ## Section One - Some info - Some other into - Some sub info ### Section One Subsection *** ## Section Two - Info - Info 2 !!! Tip This is a tip.","title":"New Page Template"},{"location":"why_software.html","text":"What is software # What is software? Why should you care? Where is software # Everywhere! Games, apps, websites All smart devices It\u2019s the stuff on your phone and computer that you see and interact with It is also handling complex parts behind what you see and interact with Even things that didn't before have software now Cars, Planes, Ovens, Light Bulbs, Garbage Trucks, Children's Toys, etc. But what is it # It\u2019s the language of computers! Logical building blocks for controlling the devices around us Software makes devices smart Software allows us to automate things Why should you do software # Learn Creative Problem Solving Peek be hind the curtain of what makes technology tick Better understanding and appreciation of technology Programming is the FUTURE Your imagination is your only limitation Low barrier to entry Only need a computing device (can be a cheap $35 computer or even your phone) Lucrative job opportunities Many job opportunities from Game Development to App Development to Robotics","title":"Why software"},{"location":"why_software.html#what-is-software","text":"What is software? Why should you care?","title":"What is software"},{"location":"why_software.html#where-is-software","text":"Everywhere! Games, apps, websites All smart devices It\u2019s the stuff on your phone and computer that you see and interact with It is also handling complex parts behind what you see and interact with Even things that didn't before have software now Cars, Planes, Ovens, Light Bulbs, Garbage Trucks, Children's Toys, etc.","title":"Where is software"},{"location":"why_software.html#but-what-is-it","text":"It\u2019s the language of computers! Logical building blocks for controlling the devices around us Software makes devices smart Software allows us to automate things","title":"But what is it"},{"location":"why_software.html#why-should-you-do-software","text":"Learn Creative Problem Solving Peek be hind the curtain of what makes technology tick Better understanding and appreciation of technology Programming is the FUTURE Your imagination is your only limitation Low barrier to entry Only need a computing device (can be a cheap $35 computer or even your phone) Lucrative job opportunities Many job opportunities from Game Development to App Development to Robotics","title":"Why should you do software"},{"location":"basics/driverstation_tips.html","text":"","title":"Driverstation tips"},{"location":"basics/java_basics.html","text":"Java Programming Basics # Learning What's What Overview # Objects, variables, and classes (in Java) make up our programs. We define, modify, and use these variables and objects to make our programs run. Programs use key words to define characteristics of variables or objects. Basic keywords: public - an object accessible by other classes (files) private - an object only accessible by its containing class (file). protected - like private but can be seen by subclasses return - value to return or give back after method execution (run). void - a method that returns no value null - a value that means empty or nothing IMPORTANT NOTE Java is case sensitive, meaning capitalization matters! Classes # Classes are the files that contain our programming A program can be made up of one class but can also be made up of many classes All programs run a main class that can optionally load additional classes either directly or indirectly Example main loads class1, class1 loads class2 Classes are made up of variables and methods and are often used to separate and organize your code. Classes can also call (use) variables or methods of other classes if those have been set to public. Constructors # Classes can also have a constructor which is a special type of method that has the same name (case sensitive) as the class file Constructors are always called when the class is loaded into the program for the first time. This is often the only time they are called. Constructors are called when trying to access the class in other files. They can be called again if the class is programmed to be unloaded (destroyed) and reloaded. Calls to methods, and assignment of values, within the constructor will run as soon as the class is called (loaded) in the code. The new operator creates an object of a type of class using a constructor Example classObject = new className(); Methods # Methods, also known as functions, can be thought of as subprograms or routines that run inside of your main program. Methods are used when you want to run the same code multiple times. Copying and pasting code is BAD! Use methods instead! Methods are also useful to access only certain parts or functions of another class. Methods can also have their own variables ( local ) or use variables available throughout the whole class ( global variables ), this will be explained more in the scope section . Methods can call (use) other methods, even multiple times. Example int value; void increment(){ value++; } Parameters # Parameters are variables that are passed (sent) to a method for it to use. You can pass more than one parameter but order matters when calling the method. Example // Example of a method with a parameter double half(int num1){ double multiplier = 0.5; return num1*multiplier; } int newNumber = half(12); // <---- Method being called (used) in code Variables # Variables are objects that contain data, they are characterized by data types Variables are assigned names and data types on creation Names can be anything with the exception of pre-existing keywords such as public or int Data types define what type of data is being stored in the variables: int - integers (whole numbers) double - double precision floating point (fractional/decimal values) boolean - true or false (true = 1 or false = 0) values. string - text values contained in parentheses Example: int sum; A variable that can hold whole number values Example: boolean isFull = true; A variable can either hold a true or false value and is being assigned a true value Constants # Most variables can have their values assigned or reassigned at any point elsewhere in your program. To avoid having a variable change its value during runtime you can make it a constant In Java you can create constants using the static final keywords together in front of the data type of the variable The static modifier causes the variable to be available without loading the class where it is defined. The final modifier causes the variable to be unchangeable. Java constants are normally declared in ALL CAPS. Words in Java constants are normally separated by underscores. Example: public static final double PI_VALUE = 3.14159; A variable that cannot be modified during code run time. Scope # When creating a variable, where you create it matters. This is known as the scope of a variable. The scope is where a variable can be seen within a class A variable created in a method can only be seen in that method. This is a local variable. A variable created outside a method can be seen in all methods of that class (file). This is a global variable. It is good practice to put them all at the top before your first method. Example of a Local Variable public int testMethod() { int example = 12; // Inside of method example = example + 1; return example } Example of a Global Variable int example = 12; // Outside of method public void testMethod() { example = example + 1; return example } Comments # Comments are a programmer-readable explanation or annotation in the source code of a program. Comments do not affect what the code does. Comments are often used to leave notes or explanations of what methods or classes are doing so that it is easier to understand the code. Example: Single Line Comments // This is what a single line comment looks like // You can also have multiple // single line comments in a row Example: Multi Line Comments /* This is what a multiline comment looks like */ Example: Doc Comments /** * This is a doc comment * * <ul> * <li>They can be viewed by hovering over code they are attached to</li> * <li>They can be formatted with HTML</li> * </ul> */ Conventions # There are also many different conventions when programming, this ensures that programs are readable between different people. A common naming convention: Programming is often done in CamelCase or lowerCamelCase Instead of adding spaces, capitalize the first letter of each word Example ThreeMotorDrive, driveForward, setSpeed Info There are other naming conventions, but for this tutorial we will use the camel cases","title":"Java Programming Basics"},{"location":"basics/java_basics.html#java-programming-basics","text":"Learning What's What","title":"Java Programming Basics"},{"location":"basics/java_basics.html#overview","text":"Objects, variables, and classes (in Java) make up our programs. We define, modify, and use these variables and objects to make our programs run. Programs use key words to define characteristics of variables or objects. Basic keywords: public - an object accessible by other classes (files) private - an object only accessible by its containing class (file). protected - like private but can be seen by subclasses return - value to return or give back after method execution (run). void - a method that returns no value null - a value that means empty or nothing IMPORTANT NOTE Java is case sensitive, meaning capitalization matters!","title":"Overview"},{"location":"basics/java_basics.html#classes","text":"Classes are the files that contain our programming A program can be made up of one class but can also be made up of many classes All programs run a main class that can optionally load additional classes either directly or indirectly Example main loads class1, class1 loads class2 Classes are made up of variables and methods and are often used to separate and organize your code. Classes can also call (use) variables or methods of other classes if those have been set to public.","title":"Classes"},{"location":"basics/java_basics.html#constructors","text":"Classes can also have a constructor which is a special type of method that has the same name (case sensitive) as the class file Constructors are always called when the class is loaded into the program for the first time. This is often the only time they are called. Constructors are called when trying to access the class in other files. They can be called again if the class is programmed to be unloaded (destroyed) and reloaded. Calls to methods, and assignment of values, within the constructor will run as soon as the class is called (loaded) in the code. The new operator creates an object of a type of class using a constructor Example classObject = new className();","title":"Constructors"},{"location":"basics/java_basics.html#methods","text":"Methods, also known as functions, can be thought of as subprograms or routines that run inside of your main program. Methods are used when you want to run the same code multiple times. Copying and pasting code is BAD! Use methods instead! Methods are also useful to access only certain parts or functions of another class. Methods can also have their own variables ( local ) or use variables available throughout the whole class ( global variables ), this will be explained more in the scope section . Methods can call (use) other methods, even multiple times. Example int value; void increment(){ value++; }","title":"Methods"},{"location":"basics/java_basics.html#parameters","text":"Parameters are variables that are passed (sent) to a method for it to use. You can pass more than one parameter but order matters when calling the method. Example // Example of a method with a parameter double half(int num1){ double multiplier = 0.5; return num1*multiplier; } int newNumber = half(12); // <---- Method being called (used) in code","title":"Parameters"},{"location":"basics/java_basics.html#variables","text":"Variables are objects that contain data, they are characterized by data types Variables are assigned names and data types on creation Names can be anything with the exception of pre-existing keywords such as public or int Data types define what type of data is being stored in the variables: int - integers (whole numbers) double - double precision floating point (fractional/decimal values) boolean - true or false (true = 1 or false = 0) values. string - text values contained in parentheses Example: int sum; A variable that can hold whole number values Example: boolean isFull = true; A variable can either hold a true or false value and is being assigned a true value","title":"Variables"},{"location":"basics/java_basics.html#constants","text":"Most variables can have their values assigned or reassigned at any point elsewhere in your program. To avoid having a variable change its value during runtime you can make it a constant In Java you can create constants using the static final keywords together in front of the data type of the variable The static modifier causes the variable to be available without loading the class where it is defined. The final modifier causes the variable to be unchangeable. Java constants are normally declared in ALL CAPS. Words in Java constants are normally separated by underscores. Example: public static final double PI_VALUE = 3.14159; A variable that cannot be modified during code run time.","title":"Constants"},{"location":"basics/java_basics.html#scope","text":"When creating a variable, where you create it matters. This is known as the scope of a variable. The scope is where a variable can be seen within a class A variable created in a method can only be seen in that method. This is a local variable. A variable created outside a method can be seen in all methods of that class (file). This is a global variable. It is good practice to put them all at the top before your first method. Example of a Local Variable public int testMethod() { int example = 12; // Inside of method example = example + 1; return example } Example of a Global Variable int example = 12; // Outside of method public void testMethod() { example = example + 1; return example }","title":"Scope"},{"location":"basics/java_basics.html#comments","text":"Comments are a programmer-readable explanation or annotation in the source code of a program. Comments do not affect what the code does. Comments are often used to leave notes or explanations of what methods or classes are doing so that it is easier to understand the code. Example: Single Line Comments // This is what a single line comment looks like // You can also have multiple // single line comments in a row Example: Multi Line Comments /* This is what a multiline comment looks like */ Example: Doc Comments /** * This is a doc comment * * <ul> * <li>They can be viewed by hovering over code they are attached to</li> * <li>They can be formatted with HTML</li> * </ul> */","title":"Comments"},{"location":"basics/java_basics.html#conventions","text":"There are also many different conventions when programming, this ensures that programs are readable between different people. A common naming convention: Programming is often done in CamelCase or lowerCamelCase Instead of adding spaces, capitalize the first letter of each word Example ThreeMotorDrive, driveForward, setSpeed Info There are other naming conventions, but for this tutorial we will use the camel cases","title":"Conventions"},{"location":"basics/roboRIO.html","text":"roboRIO # The Brains of the Bot! The roboRIO Basics # The roboRIO is the brain of an FRC robot. It is the main processing unit and is where the code is stored and run. It is very similar to something like a Raspberry Pi, it\u2019s a mini computer! The roboRIO can connect to many different devices such as motor controllers, servos, and sensors through its various interface connections such as: Digital I/O, PWM, CAN Bus, Ethernet, USB, MXP The roboRIO IO # Digital IO (DIO) used for sensors and switches PWM used for motor controllers and servos CAN used for motor controllers and sensors MXP used for functionality expansion Check the roboRIO user manual for more details","title":"roboRIO"},{"location":"basics/roboRIO.html#roborio","text":"The Brains of the Bot!","title":"roboRIO"},{"location":"basics/roboRIO.html#the-roborio-basics","text":"The roboRIO is the brain of an FRC robot. It is the main processing unit and is where the code is stored and run. It is very similar to something like a Raspberry Pi, it\u2019s a mini computer! The roboRIO can connect to many different devices such as motor controllers, servos, and sensors through its various interface connections such as: Digital I/O, PWM, CAN Bus, Ethernet, USB, MXP","title":"The roboRIO Basics"},{"location":"basics/roboRIO.html#the-roborio-io","text":"Digital IO (DIO) used for sensors and switches PWM used for motor controllers and servos CAN used for motor controllers and sensors MXP used for functionality expansion Check the roboRIO user manual for more details","title":"The roboRIO IO"},{"location":"basics/sensors.html","text":"Sensors # How does the robot see? Some types of sensors # Limit Switches - detects contact Camera - provides sight Encoders - measures rotational or linear motion Ultrasonic - measures distances Gyroscope - measures orientation Processed Vision - measures target's distance, angle, and offset from robot For more info on sensors see: High Tech High Top Hat Technicians - Electrical Tutorial Limit Switch Grayhill brand Quadrature Encoder Kauai Labs navX Gyro/ Accelerometer","title":"Sensors"},{"location":"basics/sensors.html#sensors","text":"How does the robot see?","title":"Sensors"},{"location":"basics/sensors.html#some-types-of-sensors","text":"Limit Switches - detects contact Camera - provides sight Encoders - measures rotational or linear motion Ultrasonic - measures distances Gyroscope - measures orientation Processed Vision - measures target's distance, angle, and offset from robot For more info on sensors see: High Tech High Top Hat Technicians - Electrical Tutorial Limit Switch Grayhill brand Quadrature Encoder Kauai Labs navX Gyro/ Accelerometer","title":"Some types of sensors"},{"location":"basics/vscode_tips.html","text":"Visual Studio Code Tips # Making life easier \ud83d\udca1 Using the light bulb (quick fixes) # When auto complete is available, click enter on the correct completion to auto import classes. If this is not done an error can occur denoted by an underline on what you just typed. To fix this, click on the error and click the light bulb that pops up. Then click import. From this point on this tutorial will assume you are doing this on your own so if errors occur, click the light bulb and see if it suggest importing something. The light bulb can also be used to make programming easier by auto creating things for us. This tutorial will go over that in future sections","title":"Visual Studio Code Tips"},{"location":"basics/vscode_tips.html#visual-studio-code-tips","text":"Making life easier","title":"Visual Studio Code Tips"},{"location":"basics/vscode_tips.html#using-the-light-bulb-quick-fixes","text":"When auto complete is available, click enter on the correct completion to auto import classes. If this is not done an error can occur denoted by an underline on what you just typed. To fix this, click on the error and click the light bulb that pops up. Then click import. From this point on this tutorial will assume you are doing this on your own so if errors occur, click the light bulb and see if it suggest importing something. The light bulb can also be used to make programming easier by auto creating things for us. This tutorial will go over that in future sections","title":"\ud83d\udca1 Using the light bulb (quick fixes)"},{"location":"basics/wpilib.html","text":"WPILib Programming Basics # Making FRC Programming Easy What is WPILib # The WPI Robotics library (WPILib) is a set of software classes that interfaces with the hardware and software in your FRC RoboRIO. There are classes to handle sensors, motor speed controllers, the driver station, and a number of other utility functions. Documentation is available at http://first.wpi.edu/FRC/roborio/release/docs/java WPILib adds those sensors and controllers as additional data types (like int or double ) and classes. Examples Talon , Solenoid , Encoder ... Command Based Robot # For our programming tutorial we will be creating a Command based robot Command Based Robots are much like Lego, with very basic pieces you can make something simple like a small house or complicated like an entire Lego city. A command based robot is broken down into subsystem classes and command classes. In the code, a command based robot is made up of 3 packages ( folders ) labeled robot, commands, and subsystems There are other types of robots but we will use Command Based Subsystems # A subsystem is a special template class made by FRC. In robotics, subsystems are sections of the whole robot. For example every FRC robot has a Drivetrain subsystem which is what controls the robot\u2019s driving both physically and programmatically. To avoid confusion between software and mechanical teams, subsystems should be called the same thing. If we have a ball intake system, we will both call it Intake or Collector . Subsystems of a robot can contain parts to control or read data from. The Drivetrain subsystem could contain motor controllers and encoders both physically and programmatically. Using a dog as an example: the legs , tail , and head are subsystems . The head subsystem has the parts: eyes , ears , and nose . When programming subsystems we use variables and methods to tell our subsystem what it has and what it is capable of or should do. These variables will be the parts in the subsystem These methods will define what those parts are capable of. Using a dog head subsystem as an example: Some variables (parts) would be: leftEye , rightEye , nose , leftEar , rightEar . Some example methods would be closeEyes or openEyes since these are things the dog are capable of. These methods would use both the leftEye and rightEye and close them. Example //This method closes the dog eyes public void closeEyes(){ leftEye.close(); rightEye.close(); A robot example of a Drivetrain subsystem would have leftMotor , and rightMotor as variables and setSpeed as a method telling it how to set the speed of those motor controllers. Having the setSpeed method tells our program that our Drivetrain subsystem can set its speed. Example //This method sets the speed of the drivetrain public void setSpeed(double speed){ leftMotor.set(speed); rightMotor.set(speed); } Commands # A command is a special template class (file) made by FRC. In robotics, commands are actions you want a robot to do (just like a real life command). A command is an action a subsystem(s) performs. For example you may want your robot to drive full speed forward so you make a command class called DriveForward . Since a robot uses a Drivetrain subsystem to control its motors, this command would call our previously created setSpeed method from that subsystem. Tip Subsystems define what the robot is made of and what it can do while commands actually tell the robot to do those things Using a dog as an example we can tell the dog to blink by creating a BlinkEyes command The command would call the method, closeEyes() then the method openEyes() BlinkEyes Command //This command will continuously run the two methods in execute protected void execute() { dog.head.closeEyes(); dog.head.openEyes(); } A robot example of a DriveForward command would call (use) the setSpeed methods that we created in the Drivetrain subsystem DriveForward , when executed, will tell our robot to drive forward using the Drivetrain subsystem DriveForward Command //This command tells the robot to drive forward full speed protected void initialize(){ robot.drivetrain.setSpeed(1.0); } Default Command Structure # The template for FRC commands actually come with some pre-defined methods that have special properties for FRC robots, they are: void initialize() - Methods in here are called just before this Command runs the first time. void execute() - Methods in here are called repeatedly when this Command is scheduled to run boolean isFinished() - When this returns true, the Command stops running execute() void end() - Methods in here are called once after isFinished returns true void interrupted() - Methods in here are called when another command which requires one or more of the same subsystems is scheduled to run Tip It is good practice to call end() in interrupted() Overview of execution # In FRC programming our main class is Robot.java and all other classes (command files and subsystem files) must be loaded from Robot.java either directly or indirectly Example Robot.java loads RobotContainer.java , RobotContainer.java loads DriveForward.java . All subsystem files must be added to RobotContainer.java . This loads our subsystems into the code and allow its public methods to be useable by other files such as commands later by typing RobotContainer.nameOfSubsystem.desiredMethod(); New Project Files # See Default Project Contents Summary # Command based robots are broken down into subsystems and commands Subsystems define what the robot is made of and what it can do while commands actually tell the robot to do those things All classes must directly or indirectly connect to Robot.java . All Subsystems must be added to RobotContainer.java RobotMap.java holds port numbers and IDs accessible throughout the program by typing: RobotMap.NameOfMotor() RobotContainer.java contains our publicly accessible instances of our subsystems. It also connects our commands to physical controllers.","title":"WPILib Programming Basics"},{"location":"basics/wpilib.html#wpilib-programming-basics","text":"Making FRC Programming Easy","title":"WPILib Programming Basics"},{"location":"basics/wpilib.html#what-is-wpilib","text":"The WPI Robotics library (WPILib) is a set of software classes that interfaces with the hardware and software in your FRC RoboRIO. There are classes to handle sensors, motor speed controllers, the driver station, and a number of other utility functions. Documentation is available at http://first.wpi.edu/FRC/roborio/release/docs/java WPILib adds those sensors and controllers as additional data types (like int or double ) and classes. Examples Talon , Solenoid , Encoder ...","title":"What is WPILib"},{"location":"basics/wpilib.html#command-based-robot","text":"For our programming tutorial we will be creating a Command based robot Command Based Robots are much like Lego, with very basic pieces you can make something simple like a small house or complicated like an entire Lego city. A command based robot is broken down into subsystem classes and command classes. In the code, a command based robot is made up of 3 packages ( folders ) labeled robot, commands, and subsystems There are other types of robots but we will use Command Based","title":"Command Based Robot"},{"location":"basics/wpilib.html#subsystems","text":"A subsystem is a special template class made by FRC. In robotics, subsystems are sections of the whole robot. For example every FRC robot has a Drivetrain subsystem which is what controls the robot\u2019s driving both physically and programmatically. To avoid confusion between software and mechanical teams, subsystems should be called the same thing. If we have a ball intake system, we will both call it Intake or Collector . Subsystems of a robot can contain parts to control or read data from. The Drivetrain subsystem could contain motor controllers and encoders both physically and programmatically. Using a dog as an example: the legs , tail , and head are subsystems . The head subsystem has the parts: eyes , ears , and nose . When programming subsystems we use variables and methods to tell our subsystem what it has and what it is capable of or should do. These variables will be the parts in the subsystem These methods will define what those parts are capable of. Using a dog head subsystem as an example: Some variables (parts) would be: leftEye , rightEye , nose , leftEar , rightEar . Some example methods would be closeEyes or openEyes since these are things the dog are capable of. These methods would use both the leftEye and rightEye and close them. Example //This method closes the dog eyes public void closeEyes(){ leftEye.close(); rightEye.close(); A robot example of a Drivetrain subsystem would have leftMotor , and rightMotor as variables and setSpeed as a method telling it how to set the speed of those motor controllers. Having the setSpeed method tells our program that our Drivetrain subsystem can set its speed. Example //This method sets the speed of the drivetrain public void setSpeed(double speed){ leftMotor.set(speed); rightMotor.set(speed); }","title":"Subsystems"},{"location":"basics/wpilib.html#commands","text":"A command is a special template class (file) made by FRC. In robotics, commands are actions you want a robot to do (just like a real life command). A command is an action a subsystem(s) performs. For example you may want your robot to drive full speed forward so you make a command class called DriveForward . Since a robot uses a Drivetrain subsystem to control its motors, this command would call our previously created setSpeed method from that subsystem. Tip Subsystems define what the robot is made of and what it can do while commands actually tell the robot to do those things Using a dog as an example we can tell the dog to blink by creating a BlinkEyes command The command would call the method, closeEyes() then the method openEyes() BlinkEyes Command //This command will continuously run the two methods in execute protected void execute() { dog.head.closeEyes(); dog.head.openEyes(); } A robot example of a DriveForward command would call (use) the setSpeed methods that we created in the Drivetrain subsystem DriveForward , when executed, will tell our robot to drive forward using the Drivetrain subsystem DriveForward Command //This command tells the robot to drive forward full speed protected void initialize(){ robot.drivetrain.setSpeed(1.0); }","title":"Commands"},{"location":"basics/wpilib.html#default-command-structure","text":"The template for FRC commands actually come with some pre-defined methods that have special properties for FRC robots, they are: void initialize() - Methods in here are called just before this Command runs the first time. void execute() - Methods in here are called repeatedly when this Command is scheduled to run boolean isFinished() - When this returns true, the Command stops running execute() void end() - Methods in here are called once after isFinished returns true void interrupted() - Methods in here are called when another command which requires one or more of the same subsystems is scheduled to run Tip It is good practice to call end() in interrupted()","title":"Default Command Structure"},{"location":"basics/wpilib.html#overview-of-execution","text":"In FRC programming our main class is Robot.java and all other classes (command files and subsystem files) must be loaded from Robot.java either directly or indirectly Example Robot.java loads RobotContainer.java , RobotContainer.java loads DriveForward.java . All subsystem files must be added to RobotContainer.java . This loads our subsystems into the code and allow its public methods to be useable by other files such as commands later by typing RobotContainer.nameOfSubsystem.desiredMethod();","title":"Overview of execution"},{"location":"basics/wpilib.html#new-project-files","text":"See Default Project Contents","title":"New Project Files"},{"location":"basics/wpilib.html#summary","text":"Command based robots are broken down into subsystems and commands Subsystems define what the robot is made of and what it can do while commands actually tell the robot to do those things All classes must directly or indirectly connect to Robot.java . All Subsystems must be added to RobotContainer.java RobotMap.java holds port numbers and IDs accessible throughout the program by typing: RobotMap.NameOfMotor() RobotContainer.java contains our publicly accessible instances of our subsystems. It also connects our commands to physical controllers.","title":"Summary"},{"location":"examples/basic_elevator.html","text":"[WIP] Basic Elevator Subsystem # Subtitle Overview # This section will help you learn to create a basic elevator or lift subsystem. This subsystem will contain: Two motors in a single gear box Use single encoder to lift to specific distances 3 distances 2, 5, 10 inches 3 buttons to get to those distances Hard stop safeties using limit switches Top and bottom Run motors at 25% speed so we can watch easier See table of contents for a breakdown of this section. Section One # Some info Some other into Some sub info Section One Subsection # Section Two # Info Info 2 Tip This is a tip.","title":"[WIP] Basic Elevator Subsystem"},{"location":"examples/basic_elevator.html#wip-basic-elevator-subsystem","text":"Subtitle","title":"[WIP] Basic Elevator Subsystem"},{"location":"examples/basic_elevator.html#overview","text":"This section will help you learn to create a basic elevator or lift subsystem. This subsystem will contain: Two motors in a single gear box Use single encoder to lift to specific distances 3 distances 2, 5, 10 inches 3 buttons to get to those distances Hard stop safeties using limit switches Top and bottom Run motors at 25% speed so we can watch easier See table of contents for a breakdown of this section.","title":"Overview"},{"location":"examples/basic_elevator.html#section-one","text":"Some info Some other into Some sub info","title":"Section One"},{"location":"examples/basic_elevator.html#section-one-subsection","text":"","title":"Section One Subsection"},{"location":"examples/basic_elevator.html#section-two","text":"Info Info 2 Tip This is a tip.","title":"Section Two"},{"location":"examples/basic_shooter.html","text":"[WIP] Basic Shooting Subsystem # Subtitle Overview # This section will help you learn to BLANK. See table of contents for a breakdown of this section. Section One # Some info Some other into Some sub info Section One Subsection # Section Two # Info Info 2 Tip This is a tip.","title":"[WIP] Basic Shooting Subsystem"},{"location":"examples/basic_shooter.html#wip-basic-shooting-subsystem","text":"Subtitle","title":"[WIP] Basic Shooting Subsystem"},{"location":"examples/basic_shooter.html#overview","text":"This section will help you learn to BLANK. See table of contents for a breakdown of this section.","title":"Overview"},{"location":"examples/basic_shooter.html#section-one","text":"Some info Some other into Some sub info","title":"Section One"},{"location":"examples/basic_shooter.html#section-one-subsection","text":"","title":"Section One Subsection"},{"location":"examples/basic_shooter.html#section-two","text":"Info Info 2 Tip This is a tip.","title":"Section Two"},{"location":"examples/pid_elevator.html","text":"[WIP] PID Driven Elevator # Subtitle Overview # This section will help you learn to BLANK. See table of contents for a breakdown of this section. Section One # Some info Some other into Some sub info Section One Subsection # Section Two # Info Info 2 Tip This is a tip.","title":"[WIP] PID Driven Elevator"},{"location":"examples/pid_elevator.html#wip-pid-driven-elevator","text":"Subtitle","title":"[WIP] PID Driven Elevator"},{"location":"examples/pid_elevator.html#overview","text":"This section will help you learn to BLANK. See table of contents for a breakdown of this section.","title":"Overview"},{"location":"examples/pid_elevator.html#section-one","text":"Some info Some other into Some sub info","title":"Section One"},{"location":"examples/pid_elevator.html#section-one-subsection","text":"","title":"Section One Subsection"},{"location":"examples/pid_elevator.html#section-two","text":"Info Info 2 Tip This is a tip.","title":"Section Two"},{"location":"examples/pid_shooter.html","text":"[WIP] PID Driven Shooter # Subtitle Overview # This section will help you learn to BLANK. See table of contents for a breakdown of this section. Section One # Some info Some other into Some sub info Section One Subsection # Section Two # Info Info 2 Tip This is a tip.","title":"[WIP] PID Driven Shooter"},{"location":"examples/pid_shooter.html#wip-pid-driven-shooter","text":"Subtitle","title":"[WIP] PID Driven Shooter"},{"location":"examples/pid_shooter.html#overview","text":"This section will help you learn to BLANK. See table of contents for a breakdown of this section.","title":"Overview"},{"location":"examples/pid_shooter.html#section-one","text":"Some info Some other into Some sub info","title":"Section One"},{"location":"examples/pid_shooter.html#section-one-subsection","text":"","title":"Section One Subsection"},{"location":"examples/pid_shooter.html#section-two","text":"Info Info 2 Tip This is a tip.","title":"Section Two"},{"location":"programming/autonomous.html","text":"[WIP] Creating an Autonomous Command # Overview # In this section we will be going over Creating an autonomous command group Using RobotPreferences to quickly change our autonomous values Using an encoder to autonomously drive Creating a delay timer to pace our commands in autonomous What Is an Autonomous Command # An autonomous command is a command that is ran during \"autonomous mode\" under the autonomousInit method in Robot.java It could be a single command or a command group It's especially helpful to have if you don't have any cameras to drive the robot during a \"sandstorm\" period (2019 game mechanic where the drivers couldn't see during the pre tele-op phase) For this tutorial we will create an autonomous command group that makes the robot drive forward 5 feet, wait 5 seconds, and then pitch the shooter up during autonomous Creating Commands For Autonomous # Since we can't control our robot during an autonomous command we will want to create commands that allow the robot to move independently of a driver Creating the DriveDistance Command # 1) Create a new command called DriveDistance 2) Before the constructor create a double called distance We will use this to tell the command to finish when the robot drives the inputted distance 3) In the DriveDistance constructor add a double parameter called inches 4) Inside type: distance = inches; 5) In initialize add our resetDriveEncoder method We want to reset the encoder before we drive so that it counts the distance from zero 6) In execute add our arcadeDrive method and change the moveSpeed parameter to a RobotPreference named driveDistanceSpeed and rotateSpeed to 0.0 We only want to drive the robot forward; a RobotPreference will help us tune the drive speed 7) In isFinished type: return Robot.m_drivetrain.getDriveEncoderDistance() == distance; 8) In end stop the Drivetrain and call end in interrupted Example Your full DriveDistance.java should look like this package frc.robot.commands; import edu.wpi.first.wpilibj.command.Command; import frc.robot.Robot; import frc.robot.RobotPreferences; public class DriveDistance extends Command { private double distance; public DriveDistance(double inches) { // Use requires() here to declare subsystem dependencies // eg. requires(chassis); requires(Robot.m_drivetrain); distance = inches; } // Called just before this Command runs the first time @Override protected void initialize() { Robot.m_drivetrain.resetDriveEncoder(); } // Called repeatedly when this Command is scheduled to run @Override protected void execute() { Robot.m_drivetrain.arcadeDrive(RobotPreferences.driveDistanceSpeed(), 0.0); } // Make this return true when this Command no longer needs to run execute() @Override protected boolean isFinished() { return Robot.m_drivetrain.getDriveEncoderDistance() == distance; } // Called once after isFinished returns true @Override protected void end() { Robot.m_drivetrain.arcadeDrive(0.0, 0.0); } // Called when another command which requires one or more of the same // subsystems is scheduled to run @Override protected void interrupted() { end(); } } The code you typed in RobotPreferences.java should be this public static final double driveDistanceSpeed() { return Preferences.getInstance().getDouble(\"driveDistanceSpeed\", 0.5); } Creating The Autonomous Command # We will create an Autonomous command group with the DriveDistance command and the ShooterPitchUp command 1) Create a new Command Group named Autonomous 2) In the constructor type addSequential(new DriveDistance(RobotPreferences.autoDriveDistance())); addSequential(new ShooterUp()); To add a command to run in a command group use addSequential to execute commands in order Creating the DoDelay Command # In order to add timing in between our commands in our command groups we will need to create a DoDelay command Unlike regular delays the DoDelay command will not stall our robot, but wait a certain amount of time before running a command 1) Create a new command called DoDelay 2) Before the constructor add two private doubles called expireTime and timeout 3) In the constructor add a double called seconds in the parameter 4) Inside the constructor set timeout equal to seconds 5) Create a protected void method called startTimer 6) Inside set expireTime equal to timeSinceInitialized + timeout This will let the robot know how much time will have passed since the command was initialized when it finishes 7) In initialized add our startTimer method 8) In isFinished return timeSinceInitialized is greater or equal to expireTime Example Your full DoDelay.java should look like this package frc.robot.commands; import edu.wpi.first.wpilibj.command.Command; public class DoDelay extends Command { private double expireTime; private double timeout; public DoDelay(double seconds) { // Use requires() here to declare subsystem dependencies // eg. requires(chassis); timeout = seconds; } protected void startTimer() { expireTime = timeSinceInitialized() + timeout; } // Called just before this Command runs the first time @Override protected void initialize() { startTimer(); } // Called repeatedly when this Command is scheduled to run @Override protected void execute() { } // Make this return true when this Command no longer needs to run execute() @Override protected boolean isFinished() { return (timeSinceInitialized() >= expireTime); } // Called once after isFinished returns true @Override protected void end() { } // Called when another command which requires one or more of the same // subsystems is scheduled to run @Override protected void interrupted() { } } Adding the DoDelay Command to Autonomous.java # Add our DoDelay command in between DriveDistance and ShooterPitchUp with a RobotPreference called autoDelay Example Your full Autonomous.java should look like this package frc.robot.commands; import edu.wpi.first.wpilibj.command.CommandGroup; import frc.robot.RobotPreferences; public class Autonomous extends CommandGroup { /** * Add your docs here. */ public Autonomous() { addSequential(new DriveDistance(RobotPreferences.autoDriveDistance())); addSequential(new DoDelay(RobotPreferences.autoDelay())); addSequential(new ShooterUp()); } } The code you typed in RobotPreferences.java should look like this public static double autoDelay() { return Preferences.getInstance().getDouble(\"autoDelay\", 5.0); } public static double autoDriveDistance() { return Preferences.getInstance().getDouble(\"autoDriveDistance\", 12.0); } Adding Our Autonomous Command to Robot.java # In order to run our Autonomous command in autonomous we will have to put it in Robot.java so that it will run as soon as the robot enters the autonomous mode In Robot.java under autonomousInit find m_autonomousCommand = m_chooser.getSelected(); and change it to public void autonomousInit() { m_autonomousCommand = new Autonomous(); ... Testing Our Autonomous Command # Now that we have finished coding our Autonomous command deploy code and add our new RobotPreferences to the widget on the ShuffleBoard We have three preferences that change our autonomous behavior driveDistanceSpeed , autoDriveDistance and autoDelay driveDistanceSpeed will determine the direction and how fast the robot drives autoDriveDistance will determine how many inches the robot drives forward or backward autoDelay will determine how long the robot waits before executing ShooterPitchUp Change these values before enabling your robot in autonomous to make you get the desired results Tips For Debugging Our Autonomous Command # If the robot doesn't seem to stop moving or drive in the right direction check for inversions in your Drive commands or in the Drivetrain subsystem You may also need to check if your encoder is working, if there are inversions, or if you are using the getEncoderCount method instead of the getEncoderDistanceMethod If your robot doesn't move make sure you typed in the RobotPreference names exactly or check your talon IDs/Connection If nothing happens after your robot is finished driving check your autoDelay preference and whether your Shooter piston is already actuated or if your solenoids are working","title":"[WIP] Creating an Autonomous Command"},{"location":"programming/autonomous.html#wip-creating-an-autonomous-command","text":"","title":"[WIP] Creating an Autonomous Command"},{"location":"programming/autonomous.html#overview","text":"In this section we will be going over Creating an autonomous command group Using RobotPreferences to quickly change our autonomous values Using an encoder to autonomously drive Creating a delay timer to pace our commands in autonomous","title":"Overview"},{"location":"programming/autonomous.html#what-is-an-autonomous-command","text":"An autonomous command is a command that is ran during \"autonomous mode\" under the autonomousInit method in Robot.java It could be a single command or a command group It's especially helpful to have if you don't have any cameras to drive the robot during a \"sandstorm\" period (2019 game mechanic where the drivers couldn't see during the pre tele-op phase) For this tutorial we will create an autonomous command group that makes the robot drive forward 5 feet, wait 5 seconds, and then pitch the shooter up during autonomous","title":"What Is an Autonomous Command"},{"location":"programming/autonomous.html#creating-commands-for-autonomous","text":"Since we can't control our robot during an autonomous command we will want to create commands that allow the robot to move independently of a driver","title":"Creating Commands For Autonomous"},{"location":"programming/autonomous.html#creating-the-drivedistance-command","text":"1) Create a new command called DriveDistance 2) Before the constructor create a double called distance We will use this to tell the command to finish when the robot drives the inputted distance 3) In the DriveDistance constructor add a double parameter called inches 4) Inside type: distance = inches; 5) In initialize add our resetDriveEncoder method We want to reset the encoder before we drive so that it counts the distance from zero 6) In execute add our arcadeDrive method and change the moveSpeed parameter to a RobotPreference named driveDistanceSpeed and rotateSpeed to 0.0 We only want to drive the robot forward; a RobotPreference will help us tune the drive speed 7) In isFinished type: return Robot.m_drivetrain.getDriveEncoderDistance() == distance; 8) In end stop the Drivetrain and call end in interrupted Example Your full DriveDistance.java should look like this package frc.robot.commands; import edu.wpi.first.wpilibj.command.Command; import frc.robot.Robot; import frc.robot.RobotPreferences; public class DriveDistance extends Command { private double distance; public DriveDistance(double inches) { // Use requires() here to declare subsystem dependencies // eg. requires(chassis); requires(Robot.m_drivetrain); distance = inches; } // Called just before this Command runs the first time @Override protected void initialize() { Robot.m_drivetrain.resetDriveEncoder(); } // Called repeatedly when this Command is scheduled to run @Override protected void execute() { Robot.m_drivetrain.arcadeDrive(RobotPreferences.driveDistanceSpeed(), 0.0); } // Make this return true when this Command no longer needs to run execute() @Override protected boolean isFinished() { return Robot.m_drivetrain.getDriveEncoderDistance() == distance; } // Called once after isFinished returns true @Override protected void end() { Robot.m_drivetrain.arcadeDrive(0.0, 0.0); } // Called when another command which requires one or more of the same // subsystems is scheduled to run @Override protected void interrupted() { end(); } } The code you typed in RobotPreferences.java should be this public static final double driveDistanceSpeed() { return Preferences.getInstance().getDouble(\"driveDistanceSpeed\", 0.5); }","title":"Creating the DriveDistance Command"},{"location":"programming/autonomous.html#creating-the-autonomous-command","text":"We will create an Autonomous command group with the DriveDistance command and the ShooterPitchUp command 1) Create a new Command Group named Autonomous 2) In the constructor type addSequential(new DriveDistance(RobotPreferences.autoDriveDistance())); addSequential(new ShooterUp()); To add a command to run in a command group use addSequential to execute commands in order","title":"Creating The Autonomous Command"},{"location":"programming/autonomous.html#creating-the-dodelay-command","text":"In order to add timing in between our commands in our command groups we will need to create a DoDelay command Unlike regular delays the DoDelay command will not stall our robot, but wait a certain amount of time before running a command 1) Create a new command called DoDelay 2) Before the constructor add two private doubles called expireTime and timeout 3) In the constructor add a double called seconds in the parameter 4) Inside the constructor set timeout equal to seconds 5) Create a protected void method called startTimer 6) Inside set expireTime equal to timeSinceInitialized + timeout This will let the robot know how much time will have passed since the command was initialized when it finishes 7) In initialized add our startTimer method 8) In isFinished return timeSinceInitialized is greater or equal to expireTime Example Your full DoDelay.java should look like this package frc.robot.commands; import edu.wpi.first.wpilibj.command.Command; public class DoDelay extends Command { private double expireTime; private double timeout; public DoDelay(double seconds) { // Use requires() here to declare subsystem dependencies // eg. requires(chassis); timeout = seconds; } protected void startTimer() { expireTime = timeSinceInitialized() + timeout; } // Called just before this Command runs the first time @Override protected void initialize() { startTimer(); } // Called repeatedly when this Command is scheduled to run @Override protected void execute() { } // Make this return true when this Command no longer needs to run execute() @Override protected boolean isFinished() { return (timeSinceInitialized() >= expireTime); } // Called once after isFinished returns true @Override protected void end() { } // Called when another command which requires one or more of the same // subsystems is scheduled to run @Override protected void interrupted() { } }","title":"Creating the DoDelay Command"},{"location":"programming/autonomous.html#adding-the-dodelay-command-to-autonomousjava","text":"Add our DoDelay command in between DriveDistance and ShooterPitchUp with a RobotPreference called autoDelay Example Your full Autonomous.java should look like this package frc.robot.commands; import edu.wpi.first.wpilibj.command.CommandGroup; import frc.robot.RobotPreferences; public class Autonomous extends CommandGroup { /** * Add your docs here. */ public Autonomous() { addSequential(new DriveDistance(RobotPreferences.autoDriveDistance())); addSequential(new DoDelay(RobotPreferences.autoDelay())); addSequential(new ShooterUp()); } } The code you typed in RobotPreferences.java should look like this public static double autoDelay() { return Preferences.getInstance().getDouble(\"autoDelay\", 5.0); } public static double autoDriveDistance() { return Preferences.getInstance().getDouble(\"autoDriveDistance\", 12.0); }","title":"Adding the DoDelay Command to Autonomous.java"},{"location":"programming/autonomous.html#adding-our-autonomous-command-to-robotjava","text":"In order to run our Autonomous command in autonomous we will have to put it in Robot.java so that it will run as soon as the robot enters the autonomous mode In Robot.java under autonomousInit find m_autonomousCommand = m_chooser.getSelected(); and change it to public void autonomousInit() { m_autonomousCommand = new Autonomous(); ...","title":"Adding Our Autonomous Command to Robot.java"},{"location":"programming/autonomous.html#testing-our-autonomous-command","text":"Now that we have finished coding our Autonomous command deploy code and add our new RobotPreferences to the widget on the ShuffleBoard We have three preferences that change our autonomous behavior driveDistanceSpeed , autoDriveDistance and autoDelay driveDistanceSpeed will determine the direction and how fast the robot drives autoDriveDistance will determine how many inches the robot drives forward or backward autoDelay will determine how long the robot waits before executing ShooterPitchUp Change these values before enabling your robot in autonomous to make you get the desired results","title":"Testing Our Autonomous Command"},{"location":"programming/autonomous.html#tips-for-debugging-our-autonomous-command","text":"If the robot doesn't seem to stop moving or drive in the right direction check for inversions in your Drive commands or in the Drivetrain subsystem You may also need to check if your encoder is working, if there are inversions, or if you are using the getEncoderCount method instead of the getEncoderDistanceMethod If your robot doesn't move make sure you typed in the RobotPreference names exactly or check your talon IDs/Connection If nothing happens after your robot is finished driving check your autoDelay preference and whether your Shooter piston is already actuated or if your solenoids are working","title":"Tips For Debugging Our Autonomous Command"},{"location":"programming/deploying.html","text":"Deploying Robot Code # Bring your creation to life! Overview # This section will help you learn to deploy code to your robot. See table of contents for a breakdown of this section. How to deploy # Hardware # To deploy code, first make sure your computer is connected to the robot in ONE of the following ways: USB Ethernet Robot's Wireless Network Software # Note Make sure your team number in **wpilib_preferences.json** in the **.wpilib** folder is set to the same team number your roboRIO was programmed for (it should be the number you set when creating the project and you will NOT need to check this every time as it should not change by itself). 1) Select the W icon from the tab bar or use the shortcut by holding down Ctrl+Shift+P at the same time. (Replace ctrl with cmd on macOS) 2) Type and hit enter or select: WPILib: Deploy Robot Code Tip Alternatively you can do one of the following: - Use **Shift+F5** at any time to deploy. (you may also need to hold fn depending on your computer configuration) - Right-click on the build.gradle file in the project hierarchy and select \"Build Robot Code\u201d - Open the shortcut menu indicated by the ellipses in the top right corner of the VS Code window and select \"Build Robot Code\" Testing # Open up the DriverStation software on any computer that has it installed. Enable the robot Try moving the joysticks on your controller when enabled. If it doesn\u2019t, check your port numbers for your controller, axes, and motor controllers","title":"Deploying Robot Code"},{"location":"programming/deploying.html#deploying-robot-code","text":"Bring your creation to life!","title":"Deploying Robot Code"},{"location":"programming/deploying.html#overview","text":"This section will help you learn to deploy code to your robot. See table of contents for a breakdown of this section.","title":"Overview"},{"location":"programming/deploying.html#how-to-deploy","text":"","title":"How to deploy"},{"location":"programming/deploying.html#hardware","text":"To deploy code, first make sure your computer is connected to the robot in ONE of the following ways: USB Ethernet Robot's Wireless Network","title":"Hardware"},{"location":"programming/deploying.html#software","text":"Note Make sure your team number in **wpilib_preferences.json** in the **.wpilib** folder is set to the same team number your roboRIO was programmed for (it should be the number you set when creating the project and you will NOT need to check this every time as it should not change by itself). 1) Select the W icon from the tab bar or use the shortcut by holding down Ctrl+Shift+P at the same time. (Replace ctrl with cmd on macOS) 2) Type and hit enter or select: WPILib: Deploy Robot Code Tip Alternatively you can do one of the following: - Use **Shift+F5** at any time to deploy. (you may also need to hold fn depending on your computer configuration) - Right-click on the build.gradle file in the project hierarchy and select \"Build Robot Code\u201d - Open the shortcut menu indicated by the ellipses in the top right corner of the VS Code window and select \"Build Robot Code\"","title":"Software"},{"location":"programming/deploying.html#testing","text":"Open up the DriverStation software on any computer that has it installed. Enable the robot Try moving the joysticks on your controller when enabled. If it doesn\u2019t, check your port numbers for your controller, axes, and motor controllers","title":"Testing"},{"location":"programming/driving_robot.html","text":"Creating a Basic Driving Robot # Lets get moving! Picture source: Team 2984 Overview # This section is designed to help you program a basic driving robot, start to finish. See table of contents for a breakdown of this section. Creating the Drivetrain Subsystem # Before we begin we must create the class file for the drivetrain subsystem. See Creating a New Subsystem for info on how to do this. What will be added to the Drivetrain # In the Drivetrain class we will tell the subsystem what type of components it will be using. A Drivetrain needs motor controllers. In our case we will use 4 Talon SRs (a brand of controller for motors). You could use other motor controllers such as Victor SPs or Talon SRXs but we will be using Talon SRs If you are using other motor controllers, replace Talon with TalonSRX, Victor, or VictorSP in the code you write depending on the type you use. You can use 2 motors (left and right), but for this tutorial we will use 4. Tip Be sure to read [Visual Studio Code Tips](../basics/vscode_tips.md){target=_blank} before getting started! It will make your life a lot easier. Creating the Talon Variables # 1) Create 4 global variables of data type Talon and name them: leftFrontTalon , rightFrontTalon , leftBackTalon , rightBackTalon To get started type the word Talon followed by the name i.e. Talon leftFrontTalon; These will eventually hold the object values for Talons and their port numbers. 2) Next assign their values to null ( more info on null ). We do this to make sure it is empty at this point. When we assign these variables a value, we will be getting the motor controller's port numbers out of Constants This means we cannot assign them at the global level Example The code you typed should be this: Talon leftFrontTalon = null; Talon leftBackTalon = null; Talon rightFrontTalon = null; Talon rightBackTalon = null; Your full Drivetrain.java should look like this: package frc.robot.subsystems; import edu.wpi.first.wpilibj.Talon; import edu.wpi.first.wpilibj.command.Subsystem; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null; Talon leftBackTalon = null; Talon rightFrontTalon = null; Talon rightBackTalon = null; @Override public void periodic() { // This method will be called once per scheduler run } } If an error occurs (red squiggles) Click the word Talon \ud83d\udca1 Click the light bulb Select \"Import 'Talon' (edu.wpi.first.wpilibj)\" Your error should be gone! Creating and filling the constructor # 1) Create the constructor for Drivetrain.java ( more info on constructors ) The constructor is where we will assign values to our talon variables. Now that we have created the Talons we must initialize them and tell them what port on the roboRIO they are on. 2) Initialize (set value of) leftFrontTalon to new Talon(0) . This initializes a new talon, leftFrontTalon , in a new piece of memory and states it is on port 0 of the roboRIO. This should be done within the constructor Drivetrain() The constructor Talon(int) takes a variable of type int . In this case the int (integer) refers to the port number on the roboRIO. This calls the constructor Talon(int) in the Talon class. roboRIO port diagram Example The code you typed should be this: public Drivetrain() { // Talons leftFrontTalon = new Talon(0); } Your full Drivetrain.java should look like this: package frc.robot.subsystems; import edu.wpi.first.wpilibj.Talon; import edu.wpi.first.wpilibj.command.Subsystem; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null; Talon leftBackTalon = null; Talon rightFrontTalon = null; Talon rightBackTalon = null; public Drivetrain() { // Talons leftFrontTalon = new Talon(0); } @Override public void periodic() { // This method will be called once per scheduler run } Using Constants # Since each subsystem has its own components with their own ports, it is easy to lose track of which ports are being used and for what. To counter this you can use a class called Constants to hold all these values in a single location. 1) To use Constants, instead of putting 0 for the port on the Talon type: Constants.DRIVETRAIN_LEFT_FRONT_TALON Names should follow the pattern SUBSYSTEM_NAME_OF_COMPONENT The name is all caps since it is a constant ( more info on constants ). 2) Click on the underlined text 3) Click on the \ud83d\udca1light bulb and select \u201ccreate constant\u2026\u201d 4) Click on Constants.java tab that just popped up 5) Change the 0 to the correct port for that motor controller on your robot/roboRIO Danger If you set this to the wrong value, you could damage your robot when it tries to move! 6) Repeat these steps for the remaining Talons. Tip Remember to save both Drivetrain.java and Constants.java Example The code you type should be this: leftFrontTalon = new Talon(Constants.DRIVETRAIN_LEFT_FRONT_TALON); Your full Drivetrain.java should look like this: package frc.robot.subsystems; import edu.wpi.first.wpilibj.Talon; import edu.wpi.first.wpilibj.command.Subsystem; import frc.robot.Constants; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null; Talon leftBackTalon = null; Talon rightFrontTalon = null; Talon rightBackTalon = null; public Drivetrain() { // Talons leftFrontTalon = new Talon(Constants.DRIVETRAIN_LEFT_FRONT_TALON); leftBackTalon = new Talon(Constants.DRIVETRAIN_LEFT_BACK_TALON); rightFrontTalon = new Talon(Constants.DRIVETRAIN_RIGHT_FRONT_TALON); rightBackTalon = new Talon(Constants.DRIVETRAIN_RIGHT_BACK_TALON); } @Override public void periodic() { // This method will be called once per scheduler run } } Your full Constants.java should look similar to this: package frc.robot; public class Constants { // Talons public static final int DRIVETRAIN_LEFT_FRONT_TALON = 0; public static final int DRIVETRAIN_LEFT_BACK_TALON = 1; public static final int DRIVETRAIN_RIGHT_FRONT_TALON = 2; public static final int DRIVETRAIN_RIGHT_BACK_TALON = 3; } Warning Remember to use the values for YOUR specific robot or you could risk damaging it! Creating the arcade drive # What is the Drive Class # The FIRST Drive class has many pre-configured methods available to us including DifferentialDrive, and many alterations of MecanumDrive. DifferentialDrive contains subsections such as TankDrive and ArcadeDrive. For our tutorial we will be creating an ArcadeDrive Arcade drives run by taking a moveSpeed and rotateSpeed. moveSpeed defines the forward and reverse speed and rotateSpeed defines the turning left and right speed. To create an arcade drive we will be using our already existing Drivetrain class and adding to it. Programing a RobotDrive # 1) In the same place we created our talons (outside of the constructor) we will create a DifferentialDrive and SpeedControllerGroups for our left and right motor controllers. Outside of the constructor type: SpeedControllerGroup leftMotors = null; SpeedControllerGroup rightMotors = null; DifferentialDrive differentialDrive = null; Since DifferentialDrive only takes 2 parameters we need to create speed controller groups to combine like motor controllers together. In this case we will combine the left motors together and the right motors together. Warning You should only group motors that are spinning the same direction physically when positive power is being applied otherwise you could damage your robot. 2) Now we must initialize the SpeedControllerGroups and DifferentialDrive like we did our talons. ... In the constructor type: leftMotors = new SpeedControllerGroup(leftFrontTalon, leftBackTalon); rightMotors = new SpeedControllerGroup(rightFrontTalon, rightBackTalon); differentialDrive = new DifferentialDrive(leftMotors, rightMotors); Example The code you type outside the constructor should be this: SpeedControllerGroup leftMotors = null; SpeedControllerGroup rightMotors = null; DifferentialDrive differentialDrive = null; The code you type inside the constructor should be this: leftMotors = new SpeedControllerGroup(leftFrontTalon, leftBackTalon); rightMotors = new SpeedControllerGroup(rightFrontTalon, rightBackTalon); differentialDrive = new DifferentialDrive(leftMotors, rightMotors); Your full Drivetrain.java should look like this: package frc.robot.subsystems; import edu.wpi.first.wpilibj.SpeedControllerGroup; import edu.wpi.first.wpilibj.Talon; import edu.wpi.first.wpilibj.command.Subsystem; import edu.wpi.first.wpilibj.drive.DifferentialDrive; import frc.robot.Constants; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null; Talon leftBackTalon = null; Talon rightFrontTalon = null; Talon rightBackTalon = null; SpeedControllerGroup leftMotors = null; SpeedControllerGroup rightMotors = null; DifferentialDrive differentialDrive = null; public Drivetrain() { // Talons leftFrontTalon = new Talon(Constants.DRIVETRAIN_LEFT_FRONT_TALON); leftBackTalon = new Talon(Constants.DRIVETRAIN_LEFT_BACK_TALON); rightFrontTalon = new Talon(Constants.DRIVETRAIN_RIGHT_FRONT_TALON); rightBackTalon = new Talon(Constants.DRIVETRAIN_RIGHT_BACK_TALON); leftMotors = new SpeedControllerGroup(leftFrontTalon, leftBackTalon); rightMotors = new SpeedControllerGroup(rightFrontTalon, rightBackTalon); differentialDrive = new DifferentialDrive(leftMotors, rightMotors); } @Override public void periodic() { // This method will be called once per scheduler run } } Creating the arcadeDrive method # Now it\u2019s time to make an arcadeDrive from our differentialDrive! 1) Let\u2019s create a public void method called \u201carcadeDrive\u201d with type \u201cdouble\u201d parameters moveSpeed and rotateSpeed. Below the constructor type: public void arcadeDrive(double moveSpeed, double rotateSpeed) { } Tip By putting something in the parentheses it makes the method require a parameter when it is used. When the method gets used and parameters are passed, they will be store in moveSpeed and rotateSpeed (in that order). See parameters for more info. 2) Now lets make our method call the differentialDrive's arcadeDrive method. Inside our method type: differentialDrive.arcadeDrive(moveSpeed, rotateSpeed); DifferentialDrive's arcadeDrive method takes parameters moveValue and rotateValue. Note At this point you could instead create a tank drive, however implementation differs slightly. To do so type differentialDrive.tankDrive(moveSpeed, rotateSpeed); instead of differentialDrive.arcadeDrive(moveSpeed, rotateSpeed); and change the method name reflect this. Tip If you want to limit the max speed you can multiple the speeds by a decimal (i.e. 0.5*moveSpeed will make the motors only move half of their maximum speed) You may want to do this for initial testing to make sure everything is going the right direction. Example The code you type should be this: public void arcadeDrive(double moveSpeed, double rotateSpeed) { differentialDrive.arcadeDrive(moveSpeed, rotateSpeed); } Your full Drivetrain.java should look like this: package frc.robot.subsystems; import edu.wpi.first.wpilibj.SpeedControllerGroup; import edu.wpi.first.wpilibj.Talon; import edu.wpi.first.wpilibj.command.Subsystem; import edu.wpi.first.wpilibj.drive.DifferentialDrive; import frc.robot.Constants; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null; Talon leftBackTalon = null; Talon rightFrontTalon = null; Talon rightBackTalon = null; SpeedControllerGroup leftMotors = null; SpeedControllerGroup rightMotors = null; DifferentialDrive differentialDrive = null; public Drivetrain() { // Talons leftFrontTalon = new Talon(Constants.DRIVETRAIN_LEFT_FRONT_TALON); leftBackTalon = new Talon(Constants.DRIVETRAIN_LEFT_BACK_TALON); rightFrontTalon = new Talon(Constants.DRIVETRAIN_RIGHT_FRONT_TALON); rightBackTalon = new Talon(Constants.DRIVETRAIN_RIGHT_BACK_TALON); leftMotors = new SpeedControllerGroup(leftFrontTalon, leftBackTalon); rightMotors = new SpeedControllerGroup(rightFrontTalon, rightBackTalon); differentialDrive = new DifferentialDrive(leftMotors, rightMotors); } public void arcadeDrive(double moveSpeed, double rotateSpeed) { differentialDrive.arcadeDrive(moveSpeed, rotateSpeed); } @Override public void periodic() { // This method will be called once per scheduler run } } Making our robot controllable # Creating the Joystick # In order to drive our robot, it needs to know what will be controlling it. To do so, we will create a new joystick in RobotContainer.java 1) Open RobotContainer.java 2) Type: public Joystick driverController = new Joystick(Constants.DRIVER_CONTROLLER); Import any classes if necessary such as: import edu.wpi.first.wpilibj.Joystick; A variable driverController of type Joystick pointing to a joystick on port DRIVER_CONTROLLER from Constants 3) Click the \ud83d\udca1 light bulb to create a new CONSTANT and set the value to the port number the joystick uses on the laptop (this can be found in the Driverstation software). Example The code you type should be this: public Joystick driverController = new Joystick(Constants.DRIVER_CONTROLLER); Your full RobotContainer.java should look like this: package frc.robot; import edu.wpi.first.wpilibj.Joystick; /** * This class is where the bulk of the robot should be declared. Since * Command-based is a \"declarative\" paradigm, very little robot logic should * actually be handled in the {@link Robot} periodic methods (other than the * scheduler calls). Instead, the structure of the robot (including subsystems, * commands, and button mappings) should be declared here. */ public class RobotContainer { // The robot's subsystems and commands are defined here... public Joystick driverController = new Joystick(Constants.DRIVER_CONTROLLER); } Your full Constants.java should look similar to this: package frc.robot; public class Constants { // Talons public static final int DRIVETRAIN_LEFT_FRONT_TALON = 0; public static final int DRIVETRAIN_LEFT_BACK_TALON = 1; public static final int DRIVETRAIN_RIGHT_FRONT_TALON = 2; public static final int DRIVETRAIN_RIGHT_BACK_TALON = 3; // Joysticks public static final int DRIVER_CONTROLLER = 0; } Creating the DriveArcade Command # Remember that methods tell the robot what it can do but in order to make it do these things we must give it a command . See Command Based Robot Now that we have created the method, we need to create a command to call and use that method. Let\u2019s create a new command called DriveArcade that calls arcadeDrive method we just created! Before we begin we must create the class file for the DriveArcade command. See Creating a New Command for info on how to do this and info on what each pre-created method does. In the constructor # 1) In the constructor DriveArcade() type: addRequirements(RobotContainer.m_drivetrain); This means, this command will end all other commands currently using drivetrain and will run instead when executed. It also means, other commands that require drivetrain will stop this command and run instead when executed. Warning If you use the light bulb to import \u2018Robot', be sure to import the one with \u201cfrc.robot\u201d In the execute method # 1) In the execute method we will create 2 variables of type double called moveSpeed and rotateSpeed. We want these variables to be the value of the axis of the controller we are using to drive the robot. So we will set them equal to that by using the joystick getRawAxis method. Controllers return an axis value between 1 and -1 to indicate how far the joystick is pushed up or down. Our personal controller returns up as -1 so we want to invert it. In Java you can put a negative \u201c - \u201cin front of a numeric value to invert it (value * -1) The joystick\u2019s getRawAxis method will get the position value of the axis as you move it. The method takes parameter \u201caxis number.\u201d (This can be found in the Driverstation software and we will store it in Constants). In the execute() method type: double moveSpeed = -RobotContainer.driverController.getRawAxis(Constants.DRIVER_CONTROLLER_MOVE_AXIS); double rotateSpeed = RobotContainer.driverController.getRawAxis(Constants.DRIVER_CONTROLLER_ROTATE_AXIS); Tip Remember to use the light bulb for importing and creating constants if needed! 2) Also in the execute method we will we want to call the arcadeDrive method we created in Drivetrain and give it the variables moveSpeed and rotateSpeed we created as parameters. In the execute() method below rotateSpeed type: RobotContainer.m_drivetrain.arcadeDrive(moveSpeed, rotateSpeed); In the isFinished method # Since we will be using this command to control the robot we want it to run indefinitely. 1) To do this we are going to continue having isFinished return false, meaning the command will never finish. (We don't need to change anything as this is the default) Tip If we did want a command to finish, we make this return true. This can be done by replacing false with true to make it finish instantly Alternatively we can make a condition which can return true For example (timePassed > 10) will return true after 10 seconds but return false anytime before 10 seconds have passed. In the end method # 1) We will call the arcadeDrive method and give it 0 and 0 as the parameters. In the end() method type: RobotContainer.m_drivetrain.arcadeDrive(0, 0); This make the motors stop running when the command ends by setting the movement speed to zero and rotation speed to zero. Completed Example # Example Your full Constants.java should look similar to this: package frc.robot; public class Constants { // Talons public static final int DRIVETRAIN_LEFT_FRONT_TALON = 0; public static final int DRIVETRAIN_LEFT_BACK_TALON = 1; public static final int DRIVETRAIN_RIGHT_FRONT_TALON = 2; public static final int DRIVETRAIN_RIGHT_BACK_TALON = 3; // Joysticks public static final int DRIVER_CONTROLLER = 0; public static final int DRIVER_CONTROLLER_MOVE_AXIS = 1; // Change for your controller public static final int DRIVER_CONTROLLER_ROTATE_AXIS = 2; // Change for your controller } Your full DriveArcade.java should look like this: package frc.robot.commands; import edu.wpi.first.wpilibj.command.Command; import frc.robot.RobotContainer; import frc.robot.Constants; public class DriveArcade extends Command { public DriveArcade() { // Use addRequirements() here to declare subsystem dependencies. addRequirements(RobotContainer.m_drivetrain); } // Called just before this Command runs the first time @Override protected void initialize() { } // Called repeatedly when this Command is scheduled to run @Override protected void execute() { double moveSpeed = -RobotContainer.driverController.getRawAxis(Constants.DRIVER_CONTROLLER_MOVE_AXIS); double rotateSpeed = RobotContainer.driverController.getRawAxis(Constants.DRIVER_CONTROLLER_ROTATE_AXIS); RobotContainer.m_drivetrain.arcadeDrive(moveSpeed, rotateSpeed); } // Called once the command ends or is interrupted. @Override protected void end(boolean interrupted) { Robot.m_drivetrain.arcadeDrive(0, 0); } // Make this return true when this Command no longer needs to run execute() @Override protected boolean isFinished() { return false; } } Using setDefaultCommand # Commands passed to this method will run when the robot is enabled. They also run if no other commands using the subsystem are running. This is why we write addRequirements(Robot.m_subsystemName) in the commands we create, it ends currently running commands using that subsystem to allow a new command is run. 1) Back in RobotContainer.java in the constructor we will call the setDefaultCommand of m_drivetrain and pass it the DriveArcade command In the RobotContainer.java constructor type: m_drivetrain.setDefaultCommand(new DriveArcade()); Tip Remember to use the light bulb for importing if needed! Example Your full RobotContainer.java should look like this: package frc.robot; import edu.wpi.first.wpilibj.Joystick; import frc.robot.commands.*; import frc.robot.subsystems.*; import edu.wpi.first.wpilibj2.command.Command; /** * This class is where the bulk of the robot should be declared. Since Command-based is a * \"declarative\" paradigm, very little robot logic should actually be handled in the {@link Robot} * periodic methods (other than the scheduler calls). Instead, the structure of the robot * (including subsystems, commands, and button mappings) should be declared here. */ public class RobotContainer { // The robot's subsystems and commands are defined here... public static final Drivetrain m_drivetrain = new Drivetrain(); private final ExampleSubsystem m_exampleSubsystem = new ExampleSubsystem(); private final ExampleCommand m_autoCommand = new ExampleCommand(m_exampleSubsystem); public Joystick driverController = new Joystick(Constants.DRIVER_CONTROLLER); /** * The container for the robot. Contains subsystems, OI devices, and commands. */ public RobotContainer() { // Configure the button bindings configureButtonBindings(); // Set default commands on subsystems m_drivetrain.setDefaultCommand(new DriveArcade()); } /** * Use this method to define your button->command mappings. Buttons can be created by * instantiating a {@link GenericHID} or one of its subclasses ({@link * edu.wpi.first.wpilibj.Joystick} or {@link XboxController}), and then passing it to a * {@link edu.wpi.first.wpilibj2.command.button.JoystickButton}. */ private void configureButtonBindings() { } /** * Use this to pass the autonomous command to the main {@link Robot} class. * * @return the command to run in autonomous */ public Command getAutonomousCommand() { // An ExampleCommand will run in autonomous return m_autoCommand; } }","title":"Creating a Basic Driving Robot"},{"location":"programming/driving_robot.html#creating-a-basic-driving-robot","text":"Lets get moving! Picture source: Team 2984","title":"Creating a Basic Driving Robot"},{"location":"programming/driving_robot.html#overview","text":"This section is designed to help you program a basic driving robot, start to finish. See table of contents for a breakdown of this section.","title":"Overview"},{"location":"programming/driving_robot.html#creating-the-drivetrain-subsystem","text":"Before we begin we must create the class file for the drivetrain subsystem. See Creating a New Subsystem for info on how to do this.","title":"Creating the Drivetrain Subsystem"},{"location":"programming/driving_robot.html#what-will-be-added-to-the-drivetrain","text":"In the Drivetrain class we will tell the subsystem what type of components it will be using. A Drivetrain needs motor controllers. In our case we will use 4 Talon SRs (a brand of controller for motors). You could use other motor controllers such as Victor SPs or Talon SRXs but we will be using Talon SRs If you are using other motor controllers, replace Talon with TalonSRX, Victor, or VictorSP in the code you write depending on the type you use. You can use 2 motors (left and right), but for this tutorial we will use 4. Tip Be sure to read [Visual Studio Code Tips](../basics/vscode_tips.md){target=_blank} before getting started! It will make your life a lot easier.","title":"What will be added to the Drivetrain"},{"location":"programming/driving_robot.html#creating-the-talon-variables","text":"1) Create 4 global variables of data type Talon and name them: leftFrontTalon , rightFrontTalon , leftBackTalon , rightBackTalon To get started type the word Talon followed by the name i.e. Talon leftFrontTalon; These will eventually hold the object values for Talons and their port numbers. 2) Next assign their values to null ( more info on null ). We do this to make sure it is empty at this point. When we assign these variables a value, we will be getting the motor controller's port numbers out of Constants This means we cannot assign them at the global level Example The code you typed should be this: Talon leftFrontTalon = null; Talon leftBackTalon = null; Talon rightFrontTalon = null; Talon rightBackTalon = null; Your full Drivetrain.java should look like this: package frc.robot.subsystems; import edu.wpi.first.wpilibj.Talon; import edu.wpi.first.wpilibj.command.Subsystem; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null; Talon leftBackTalon = null; Talon rightFrontTalon = null; Talon rightBackTalon = null; @Override public void periodic() { // This method will be called once per scheduler run } } If an error occurs (red squiggles) Click the word Talon \ud83d\udca1 Click the light bulb Select \"Import 'Talon' (edu.wpi.first.wpilibj)\" Your error should be gone!","title":"Creating the Talon Variables"},{"location":"programming/driving_robot.html#creating-and-filling-the-constructor","text":"1) Create the constructor for Drivetrain.java ( more info on constructors ) The constructor is where we will assign values to our talon variables. Now that we have created the Talons we must initialize them and tell them what port on the roboRIO they are on. 2) Initialize (set value of) leftFrontTalon to new Talon(0) . This initializes a new talon, leftFrontTalon , in a new piece of memory and states it is on port 0 of the roboRIO. This should be done within the constructor Drivetrain() The constructor Talon(int) takes a variable of type int . In this case the int (integer) refers to the port number on the roboRIO. This calls the constructor Talon(int) in the Talon class. roboRIO port diagram Example The code you typed should be this: public Drivetrain() { // Talons leftFrontTalon = new Talon(0); } Your full Drivetrain.java should look like this: package frc.robot.subsystems; import edu.wpi.first.wpilibj.Talon; import edu.wpi.first.wpilibj.command.Subsystem; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null; Talon leftBackTalon = null; Talon rightFrontTalon = null; Talon rightBackTalon = null; public Drivetrain() { // Talons leftFrontTalon = new Talon(0); } @Override public void periodic() { // This method will be called once per scheduler run }","title":"Creating and filling the constructor"},{"location":"programming/driving_robot.html#using-constants","text":"Since each subsystem has its own components with their own ports, it is easy to lose track of which ports are being used and for what. To counter this you can use a class called Constants to hold all these values in a single location. 1) To use Constants, instead of putting 0 for the port on the Talon type: Constants.DRIVETRAIN_LEFT_FRONT_TALON Names should follow the pattern SUBSYSTEM_NAME_OF_COMPONENT The name is all caps since it is a constant ( more info on constants ). 2) Click on the underlined text 3) Click on the \ud83d\udca1light bulb and select \u201ccreate constant\u2026\u201d 4) Click on Constants.java tab that just popped up 5) Change the 0 to the correct port for that motor controller on your robot/roboRIO Danger If you set this to the wrong value, you could damage your robot when it tries to move! 6) Repeat these steps for the remaining Talons. Tip Remember to save both Drivetrain.java and Constants.java Example The code you type should be this: leftFrontTalon = new Talon(Constants.DRIVETRAIN_LEFT_FRONT_TALON); Your full Drivetrain.java should look like this: package frc.robot.subsystems; import edu.wpi.first.wpilibj.Talon; import edu.wpi.first.wpilibj.command.Subsystem; import frc.robot.Constants; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null; Talon leftBackTalon = null; Talon rightFrontTalon = null; Talon rightBackTalon = null; public Drivetrain() { // Talons leftFrontTalon = new Talon(Constants.DRIVETRAIN_LEFT_FRONT_TALON); leftBackTalon = new Talon(Constants.DRIVETRAIN_LEFT_BACK_TALON); rightFrontTalon = new Talon(Constants.DRIVETRAIN_RIGHT_FRONT_TALON); rightBackTalon = new Talon(Constants.DRIVETRAIN_RIGHT_BACK_TALON); } @Override public void periodic() { // This method will be called once per scheduler run } } Your full Constants.java should look similar to this: package frc.robot; public class Constants { // Talons public static final int DRIVETRAIN_LEFT_FRONT_TALON = 0; public static final int DRIVETRAIN_LEFT_BACK_TALON = 1; public static final int DRIVETRAIN_RIGHT_FRONT_TALON = 2; public static final int DRIVETRAIN_RIGHT_BACK_TALON = 3; } Warning Remember to use the values for YOUR specific robot or you could risk damaging it!","title":"Using Constants"},{"location":"programming/driving_robot.html#creating-the-arcade-drive","text":"","title":"Creating the arcade drive"},{"location":"programming/driving_robot.html#what-is-the-drive-class","text":"The FIRST Drive class has many pre-configured methods available to us including DifferentialDrive, and many alterations of MecanumDrive. DifferentialDrive contains subsections such as TankDrive and ArcadeDrive. For our tutorial we will be creating an ArcadeDrive Arcade drives run by taking a moveSpeed and rotateSpeed. moveSpeed defines the forward and reverse speed and rotateSpeed defines the turning left and right speed. To create an arcade drive we will be using our already existing Drivetrain class and adding to it.","title":"What is the Drive Class"},{"location":"programming/driving_robot.html#programing-a-robotdrive","text":"1) In the same place we created our talons (outside of the constructor) we will create a DifferentialDrive and SpeedControllerGroups for our left and right motor controllers. Outside of the constructor type: SpeedControllerGroup leftMotors = null; SpeedControllerGroup rightMotors = null; DifferentialDrive differentialDrive = null; Since DifferentialDrive only takes 2 parameters we need to create speed controller groups to combine like motor controllers together. In this case we will combine the left motors together and the right motors together. Warning You should only group motors that are spinning the same direction physically when positive power is being applied otherwise you could damage your robot. 2) Now we must initialize the SpeedControllerGroups and DifferentialDrive like we did our talons. ... In the constructor type: leftMotors = new SpeedControllerGroup(leftFrontTalon, leftBackTalon); rightMotors = new SpeedControllerGroup(rightFrontTalon, rightBackTalon); differentialDrive = new DifferentialDrive(leftMotors, rightMotors); Example The code you type outside the constructor should be this: SpeedControllerGroup leftMotors = null; SpeedControllerGroup rightMotors = null; DifferentialDrive differentialDrive = null; The code you type inside the constructor should be this: leftMotors = new SpeedControllerGroup(leftFrontTalon, leftBackTalon); rightMotors = new SpeedControllerGroup(rightFrontTalon, rightBackTalon); differentialDrive = new DifferentialDrive(leftMotors, rightMotors); Your full Drivetrain.java should look like this: package frc.robot.subsystems; import edu.wpi.first.wpilibj.SpeedControllerGroup; import edu.wpi.first.wpilibj.Talon; import edu.wpi.first.wpilibj.command.Subsystem; import edu.wpi.first.wpilibj.drive.DifferentialDrive; import frc.robot.Constants; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null; Talon leftBackTalon = null; Talon rightFrontTalon = null; Talon rightBackTalon = null; SpeedControllerGroup leftMotors = null; SpeedControllerGroup rightMotors = null; DifferentialDrive differentialDrive = null; public Drivetrain() { // Talons leftFrontTalon = new Talon(Constants.DRIVETRAIN_LEFT_FRONT_TALON); leftBackTalon = new Talon(Constants.DRIVETRAIN_LEFT_BACK_TALON); rightFrontTalon = new Talon(Constants.DRIVETRAIN_RIGHT_FRONT_TALON); rightBackTalon = new Talon(Constants.DRIVETRAIN_RIGHT_BACK_TALON); leftMotors = new SpeedControllerGroup(leftFrontTalon, leftBackTalon); rightMotors = new SpeedControllerGroup(rightFrontTalon, rightBackTalon); differentialDrive = new DifferentialDrive(leftMotors, rightMotors); } @Override public void periodic() { // This method will be called once per scheduler run } }","title":"Programing a RobotDrive"},{"location":"programming/driving_robot.html#creating-the-arcadedrive-method","text":"Now it\u2019s time to make an arcadeDrive from our differentialDrive! 1) Let\u2019s create a public void method called \u201carcadeDrive\u201d with type \u201cdouble\u201d parameters moveSpeed and rotateSpeed. Below the constructor type: public void arcadeDrive(double moveSpeed, double rotateSpeed) { } Tip By putting something in the parentheses it makes the method require a parameter when it is used. When the method gets used and parameters are passed, they will be store in moveSpeed and rotateSpeed (in that order). See parameters for more info. 2) Now lets make our method call the differentialDrive's arcadeDrive method. Inside our method type: differentialDrive.arcadeDrive(moveSpeed, rotateSpeed); DifferentialDrive's arcadeDrive method takes parameters moveValue and rotateValue. Note At this point you could instead create a tank drive, however implementation differs slightly. To do so type differentialDrive.tankDrive(moveSpeed, rotateSpeed); instead of differentialDrive.arcadeDrive(moveSpeed, rotateSpeed); and change the method name reflect this. Tip If you want to limit the max speed you can multiple the speeds by a decimal (i.e. 0.5*moveSpeed will make the motors only move half of their maximum speed) You may want to do this for initial testing to make sure everything is going the right direction. Example The code you type should be this: public void arcadeDrive(double moveSpeed, double rotateSpeed) { differentialDrive.arcadeDrive(moveSpeed, rotateSpeed); } Your full Drivetrain.java should look like this: package frc.robot.subsystems; import edu.wpi.first.wpilibj.SpeedControllerGroup; import edu.wpi.first.wpilibj.Talon; import edu.wpi.first.wpilibj.command.Subsystem; import edu.wpi.first.wpilibj.drive.DifferentialDrive; import frc.robot.Constants; /** * Add your docs here. */ public class Drivetrain extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. Talon leftFrontTalon = null; Talon leftBackTalon = null; Talon rightFrontTalon = null; Talon rightBackTalon = null; SpeedControllerGroup leftMotors = null; SpeedControllerGroup rightMotors = null; DifferentialDrive differentialDrive = null; public Drivetrain() { // Talons leftFrontTalon = new Talon(Constants.DRIVETRAIN_LEFT_FRONT_TALON); leftBackTalon = new Talon(Constants.DRIVETRAIN_LEFT_BACK_TALON); rightFrontTalon = new Talon(Constants.DRIVETRAIN_RIGHT_FRONT_TALON); rightBackTalon = new Talon(Constants.DRIVETRAIN_RIGHT_BACK_TALON); leftMotors = new SpeedControllerGroup(leftFrontTalon, leftBackTalon); rightMotors = new SpeedControllerGroup(rightFrontTalon, rightBackTalon); differentialDrive = new DifferentialDrive(leftMotors, rightMotors); } public void arcadeDrive(double moveSpeed, double rotateSpeed) { differentialDrive.arcadeDrive(moveSpeed, rotateSpeed); } @Override public void periodic() { // This method will be called once per scheduler run } }","title":"Creating the arcadeDrive method"},{"location":"programming/driving_robot.html#making-our-robot-controllable","text":"","title":"Making our robot controllable"},{"location":"programming/driving_robot.html#creating-the-joystick","text":"In order to drive our robot, it needs to know what will be controlling it. To do so, we will create a new joystick in RobotContainer.java 1) Open RobotContainer.java 2) Type: public Joystick driverController = new Joystick(Constants.DRIVER_CONTROLLER); Import any classes if necessary such as: import edu.wpi.first.wpilibj.Joystick; A variable driverController of type Joystick pointing to a joystick on port DRIVER_CONTROLLER from Constants 3) Click the \ud83d\udca1 light bulb to create a new CONSTANT and set the value to the port number the joystick uses on the laptop (this can be found in the Driverstation software). Example The code you type should be this: public Joystick driverController = new Joystick(Constants.DRIVER_CONTROLLER); Your full RobotContainer.java should look like this: package frc.robot; import edu.wpi.first.wpilibj.Joystick; /** * This class is where the bulk of the robot should be declared. Since * Command-based is a \"declarative\" paradigm, very little robot logic should * actually be handled in the {@link Robot} periodic methods (other than the * scheduler calls). Instead, the structure of the robot (including subsystems, * commands, and button mappings) should be declared here. */ public class RobotContainer { // The robot's subsystems and commands are defined here... public Joystick driverController = new Joystick(Constants.DRIVER_CONTROLLER); } Your full Constants.java should look similar to this: package frc.robot; public class Constants { // Talons public static final int DRIVETRAIN_LEFT_FRONT_TALON = 0; public static final int DRIVETRAIN_LEFT_BACK_TALON = 1; public static final int DRIVETRAIN_RIGHT_FRONT_TALON = 2; public static final int DRIVETRAIN_RIGHT_BACK_TALON = 3; // Joysticks public static final int DRIVER_CONTROLLER = 0; }","title":"Creating the Joystick"},{"location":"programming/driving_robot.html#creating-the-drivearcade-command","text":"Remember that methods tell the robot what it can do but in order to make it do these things we must give it a command . See Command Based Robot Now that we have created the method, we need to create a command to call and use that method. Let\u2019s create a new command called DriveArcade that calls arcadeDrive method we just created! Before we begin we must create the class file for the DriveArcade command. See Creating a New Command for info on how to do this and info on what each pre-created method does.","title":"Creating the DriveArcade Command"},{"location":"programming/driving_robot.html#in-the-constructor","text":"1) In the constructor DriveArcade() type: addRequirements(RobotContainer.m_drivetrain); This means, this command will end all other commands currently using drivetrain and will run instead when executed. It also means, other commands that require drivetrain will stop this command and run instead when executed. Warning If you use the light bulb to import \u2018Robot', be sure to import the one with \u201cfrc.robot\u201d","title":"In the constructor"},{"location":"programming/driving_robot.html#in-the-execute-method","text":"1) In the execute method we will create 2 variables of type double called moveSpeed and rotateSpeed. We want these variables to be the value of the axis of the controller we are using to drive the robot. So we will set them equal to that by using the joystick getRawAxis method. Controllers return an axis value between 1 and -1 to indicate how far the joystick is pushed up or down. Our personal controller returns up as -1 so we want to invert it. In Java you can put a negative \u201c - \u201cin front of a numeric value to invert it (value * -1) The joystick\u2019s getRawAxis method will get the position value of the axis as you move it. The method takes parameter \u201caxis number.\u201d (This can be found in the Driverstation software and we will store it in Constants). In the execute() method type: double moveSpeed = -RobotContainer.driverController.getRawAxis(Constants.DRIVER_CONTROLLER_MOVE_AXIS); double rotateSpeed = RobotContainer.driverController.getRawAxis(Constants.DRIVER_CONTROLLER_ROTATE_AXIS); Tip Remember to use the light bulb for importing and creating constants if needed! 2) Also in the execute method we will we want to call the arcadeDrive method we created in Drivetrain and give it the variables moveSpeed and rotateSpeed we created as parameters. In the execute() method below rotateSpeed type: RobotContainer.m_drivetrain.arcadeDrive(moveSpeed, rotateSpeed);","title":"In the execute method"},{"location":"programming/driving_robot.html#in-the-isfinished-method","text":"Since we will be using this command to control the robot we want it to run indefinitely. 1) To do this we are going to continue having isFinished return false, meaning the command will never finish. (We don't need to change anything as this is the default) Tip If we did want a command to finish, we make this return true. This can be done by replacing false with true to make it finish instantly Alternatively we can make a condition which can return true For example (timePassed > 10) will return true after 10 seconds but return false anytime before 10 seconds have passed.","title":"In the isFinished method"},{"location":"programming/driving_robot.html#in-the-end-method","text":"1) We will call the arcadeDrive method and give it 0 and 0 as the parameters. In the end() method type: RobotContainer.m_drivetrain.arcadeDrive(0, 0); This make the motors stop running when the command ends by setting the movement speed to zero and rotation speed to zero.","title":"In the end method"},{"location":"programming/driving_robot.html#completed-example","text":"Example Your full Constants.java should look similar to this: package frc.robot; public class Constants { // Talons public static final int DRIVETRAIN_LEFT_FRONT_TALON = 0; public static final int DRIVETRAIN_LEFT_BACK_TALON = 1; public static final int DRIVETRAIN_RIGHT_FRONT_TALON = 2; public static final int DRIVETRAIN_RIGHT_BACK_TALON = 3; // Joysticks public static final int DRIVER_CONTROLLER = 0; public static final int DRIVER_CONTROLLER_MOVE_AXIS = 1; // Change for your controller public static final int DRIVER_CONTROLLER_ROTATE_AXIS = 2; // Change for your controller } Your full DriveArcade.java should look like this: package frc.robot.commands; import edu.wpi.first.wpilibj.command.Command; import frc.robot.RobotContainer; import frc.robot.Constants; public class DriveArcade extends Command { public DriveArcade() { // Use addRequirements() here to declare subsystem dependencies. addRequirements(RobotContainer.m_drivetrain); } // Called just before this Command runs the first time @Override protected void initialize() { } // Called repeatedly when this Command is scheduled to run @Override protected void execute() { double moveSpeed = -RobotContainer.driverController.getRawAxis(Constants.DRIVER_CONTROLLER_MOVE_AXIS); double rotateSpeed = RobotContainer.driverController.getRawAxis(Constants.DRIVER_CONTROLLER_ROTATE_AXIS); RobotContainer.m_drivetrain.arcadeDrive(moveSpeed, rotateSpeed); } // Called once the command ends or is interrupted. @Override protected void end(boolean interrupted) { Robot.m_drivetrain.arcadeDrive(0, 0); } // Make this return true when this Command no longer needs to run execute() @Override protected boolean isFinished() { return false; } }","title":"Completed Example"},{"location":"programming/driving_robot.html#using-setdefaultcommand","text":"Commands passed to this method will run when the robot is enabled. They also run if no other commands using the subsystem are running. This is why we write addRequirements(Robot.m_subsystemName) in the commands we create, it ends currently running commands using that subsystem to allow a new command is run. 1) Back in RobotContainer.java in the constructor we will call the setDefaultCommand of m_drivetrain and pass it the DriveArcade command In the RobotContainer.java constructor type: m_drivetrain.setDefaultCommand(new DriveArcade()); Tip Remember to use the light bulb for importing if needed! Example Your full RobotContainer.java should look like this: package frc.robot; import edu.wpi.first.wpilibj.Joystick; import frc.robot.commands.*; import frc.robot.subsystems.*; import edu.wpi.first.wpilibj2.command.Command; /** * This class is where the bulk of the robot should be declared. Since Command-based is a * \"declarative\" paradigm, very little robot logic should actually be handled in the {@link Robot} * periodic methods (other than the scheduler calls). Instead, the structure of the robot * (including subsystems, commands, and button mappings) should be declared here. */ public class RobotContainer { // The robot's subsystems and commands are defined here... public static final Drivetrain m_drivetrain = new Drivetrain(); private final ExampleSubsystem m_exampleSubsystem = new ExampleSubsystem(); private final ExampleCommand m_autoCommand = new ExampleCommand(m_exampleSubsystem); public Joystick driverController = new Joystick(Constants.DRIVER_CONTROLLER); /** * The container for the robot. Contains subsystems, OI devices, and commands. */ public RobotContainer() { // Configure the button bindings configureButtonBindings(); // Set default commands on subsystems m_drivetrain.setDefaultCommand(new DriveArcade()); } /** * Use this method to define your button->command mappings. Buttons can be created by * instantiating a {@link GenericHID} or one of its subclasses ({@link * edu.wpi.first.wpilibj.Joystick} or {@link XboxController}), and then passing it to a * {@link edu.wpi.first.wpilibj2.command.button.JoystickButton}. */ private void configureButtonBindings() { } /** * Use this to pass the autonomous command to the main {@link Robot} class. * * @return the command to run in autonomous */ public Command getAutonomousCommand() { // An ExampleCommand will run in autonomous return m_autoCommand; } }","title":"Using setDefaultCommand"},{"location":"programming/new_project.html","text":"Creating Project Files # Lets get started Overview # Before we can start programing a robot, we must create a new project in Visual Studio Code (VSCode). See table of contents for a breakdown of this section. Creating a New Project # 1) Select the W icon from the tab bar or use the shortcut by holding down Ctrl+Shift+P at the same time. (Replace ctrl with command on macOS) 2) Type and hit enter or select WPILib: Create a new project 3) Click Select a Project Type and choose Template 4) Click Select a Language and choose Java 5) Click Select a project base and choose Command Robot 6) Click Select a new project folder and choose where on your computer you would like to store the program 7) Enter a project name in the text field labeled as such 8) Enter your team number in the text field labeled as such 9) Select Generate Project 10) When prompted \u201cWould you like to open the folder?\u201d , select Yes (Current Window) Default Project Contents # Newly created projects have many files within them. We only care about the contents within the src/main/java/frc/robot/ folder. Everything else can be ignored at this point in the tutorial. Files in the robot folder: ExampleCommand.java An example Command ExampleSubsystem.java An example SubSystem Constants.java (new in 2020, replaces RobotMap.java) Used to map physical ports (digital if using the CAN bus) of sensors or devices connected to the robot and assign them a variable name to be used in other parts of the code. This provides flexibility for changing wiring, makes checking the wiring easier, and significantly reduces the number of magic numbers floating around. Can also be used to store generic constant values as variables in the code Main.java Used for advanced programming Will be ignored/left as is for this tutorial RobotContainer.java (new in 2020, replaces OI.java) Used to declare our subsystem Used to create a connection between commands and Operator Interfaces (OI) such as Joysticks or buttons Robot.java The main class of the robot which is run when a robot boots up. Used to run special methods in the init and period phases of the auto, teleop, and disabled states Example Creating a New Subsystem # 1) Click on the src folder to expand it. 2) Do the same for java then subsystems 3) Right click on subsystems and select Create a new class/ command. 4) Select Subsystem (New) and type your DesiredSubsystemName (i.e. Drivetrain ) for the name and hit enter on your keyboard. 5) Click on the newly created DesiredSubsystemName.java (or Drivetrain.java if you named it that) Adding the Subsystem to RobotContainer.java # Do not forget this step! When a robot program runs on the roboRIO it only runs the main file Robot.java and anything Robot.java links to such as RobotContainer.java. We have created a new subsystem but we have not yet linked it to Robot.java through RobotContainer.java. We must do this for EVERY subsystem we create 1) In RobotContainer.java we will create a new public global constant variable of type DesiredSubsystemName (i.e. Drivetrain ): public static final m_desiredSubsystemName = new DesiredSubsystemName(); (i.e. public static final m_drivetrain = new Drivetrain(); ) Now when we use this subsystem in commands, we must call RobotContainer.m_desiredSubsystemName. to get access to it and its methods. (i.e. RobotContainer.m_drivetrain.someMethod() ) Default Subsystem Contents # Newly created subsystems are empty with the exception of the periodic. Currently there is no constructor, we will create a constructor ourselves later. periodic - a method that will be called periodically (once per robot scheduler run) Useful for adding/updating data to Driverstation dashboard Useful updating variables that need to always up to date Example package frc.robot.subsystems; import edu.wpi.first.wpilibj2.command.SubsystemBase; public class Drivetrain extends SubsystemBase { /** * Creates a new Drivetrain. */ public Drivetrain() { } @Override public void periodic() { // This method will be called once per scheduler run } } Creating a New Command # 1) Click on the src folder to expand it (if it isn't already). 2) Do the same for commands 3) Right click on commands and select Create a new class/ command. 4) Select Command (New) and type DesiredCommandName (i.e. DriveArcade) for the name and hit enter on your keyboard. 5) Click on the newly created DesiredCommandName.java (or DriveArcade.java if you named it that) Default Command Contents # Newly created commands have some predefined methods in them specific for a command based robot. Constructor - Called when the robot program is FIRST loaded. Subsystem dependencies are declared here. initialize() - Called ONCE just before this Command runs the first time. execute() - Called REPEATEDLY when this Command is scheduled to run end() - Called ONCE after isFinished returns true or when another command which requires one or more of the same subsystems is scheduled to run isFinished() - Make this return TRUE when this Command no longer needs to run execute() (initialize always runs once regardless). Example package frc.robot.commands; import edu.wpi.first.wpilibj2.command.CommandBase; public class DriveArcade extends CommandBase { /** * Creates a new DriveArcade. */ public DriveArcade() { // Use addRequirements() here to declare subsystem dependencies. } // Called when the command is initially scheduled. @Override public void initialize() { } // Called every time the scheduler runs while the command is scheduled. @Override public void execute() { } // Called once the command ends or is interrupted. @Override public void end(boolean interrupted) { } // Returns true when the command should end. @Override public boolean isFinished() { return false; } }","title":"Creating Project Files"},{"location":"programming/new_project.html#creating-project-files","text":"Lets get started","title":"Creating Project Files"},{"location":"programming/new_project.html#overview","text":"Before we can start programing a robot, we must create a new project in Visual Studio Code (VSCode). See table of contents for a breakdown of this section.","title":"Overview"},{"location":"programming/new_project.html#creating-a-new-project","text":"1) Select the W icon from the tab bar or use the shortcut by holding down Ctrl+Shift+P at the same time. (Replace ctrl with command on macOS) 2) Type and hit enter or select WPILib: Create a new project 3) Click Select a Project Type and choose Template 4) Click Select a Language and choose Java 5) Click Select a project base and choose Command Robot 6) Click Select a new project folder and choose where on your computer you would like to store the program 7) Enter a project name in the text field labeled as such 8) Enter your team number in the text field labeled as such 9) Select Generate Project 10) When prompted \u201cWould you like to open the folder?\u201d , select Yes (Current Window)","title":"Creating a New Project"},{"location":"programming/new_project.html#default-project-contents","text":"Newly created projects have many files within them. We only care about the contents within the src/main/java/frc/robot/ folder. Everything else can be ignored at this point in the tutorial. Files in the robot folder: ExampleCommand.java An example Command ExampleSubsystem.java An example SubSystem Constants.java (new in 2020, replaces RobotMap.java) Used to map physical ports (digital if using the CAN bus) of sensors or devices connected to the robot and assign them a variable name to be used in other parts of the code. This provides flexibility for changing wiring, makes checking the wiring easier, and significantly reduces the number of magic numbers floating around. Can also be used to store generic constant values as variables in the code Main.java Used for advanced programming Will be ignored/left as is for this tutorial RobotContainer.java (new in 2020, replaces OI.java) Used to declare our subsystem Used to create a connection between commands and Operator Interfaces (OI) such as Joysticks or buttons Robot.java The main class of the robot which is run when a robot boots up. Used to run special methods in the init and period phases of the auto, teleop, and disabled states Example","title":"Default Project Contents"},{"location":"programming/new_project.html#creating-a-new-subsystem","text":"1) Click on the src folder to expand it. 2) Do the same for java then subsystems 3) Right click on subsystems and select Create a new class/ command. 4) Select Subsystem (New) and type your DesiredSubsystemName (i.e. Drivetrain ) for the name and hit enter on your keyboard. 5) Click on the newly created DesiredSubsystemName.java (or Drivetrain.java if you named it that)","title":"Creating a New Subsystem"},{"location":"programming/new_project.html#adding-the-subsystem-to-robotcontainerjava","text":"Do not forget this step! When a robot program runs on the roboRIO it only runs the main file Robot.java and anything Robot.java links to such as RobotContainer.java. We have created a new subsystem but we have not yet linked it to Robot.java through RobotContainer.java. We must do this for EVERY subsystem we create 1) In RobotContainer.java we will create a new public global constant variable of type DesiredSubsystemName (i.e. Drivetrain ): public static final m_desiredSubsystemName = new DesiredSubsystemName(); (i.e. public static final m_drivetrain = new Drivetrain(); ) Now when we use this subsystem in commands, we must call RobotContainer.m_desiredSubsystemName. to get access to it and its methods. (i.e. RobotContainer.m_drivetrain.someMethod() )","title":"Adding the Subsystem to RobotContainer.java"},{"location":"programming/new_project.html#default-subsystem-contents","text":"Newly created subsystems are empty with the exception of the periodic. Currently there is no constructor, we will create a constructor ourselves later. periodic - a method that will be called periodically (once per robot scheduler run) Useful for adding/updating data to Driverstation dashboard Useful updating variables that need to always up to date Example package frc.robot.subsystems; import edu.wpi.first.wpilibj2.command.SubsystemBase; public class Drivetrain extends SubsystemBase { /** * Creates a new Drivetrain. */ public Drivetrain() { } @Override public void periodic() { // This method will be called once per scheduler run } }","title":"Default Subsystem Contents"},{"location":"programming/new_project.html#creating-a-new-command","text":"1) Click on the src folder to expand it (if it isn't already). 2) Do the same for commands 3) Right click on commands and select Create a new class/ command. 4) Select Command (New) and type DesiredCommandName (i.e. DriveArcade) for the name and hit enter on your keyboard. 5) Click on the newly created DesiredCommandName.java (or DriveArcade.java if you named it that)","title":"Creating a New Command"},{"location":"programming/new_project.html#default-command-contents","text":"Newly created commands have some predefined methods in them specific for a command based robot. Constructor - Called when the robot program is FIRST loaded. Subsystem dependencies are declared here. initialize() - Called ONCE just before this Command runs the first time. execute() - Called REPEATEDLY when this Command is scheduled to run end() - Called ONCE after isFinished returns true or when another command which requires one or more of the same subsystems is scheduled to run isFinished() - Make this return TRUE when this Command no longer needs to run execute() (initialize always runs once regardless). Example package frc.robot.commands; import edu.wpi.first.wpilibj2.command.CommandBase; public class DriveArcade extends CommandBase { /** * Creates a new DriveArcade. */ public DriveArcade() { // Use addRequirements() here to declare subsystem dependencies. } // Called when the command is initially scheduled. @Override public void initialize() { } // Called every time the scheduler runs while the command is scheduled. @Override public void execute() { } // Called once the command ends or is interrupted. @Override public void end(boolean interrupted) { } // Returns true when the command should end. @Override public boolean isFinished() { return false; } }","title":"Default Command Contents"},{"location":"programming/pid.html","text":"[WIP] Getting started with PID # This page is currently a work in progress. Check back later","title":"[WIP] Getting started with PID"},{"location":"programming/pid.html#wip-getting-started-with-pid","text":"This page is currently a work in progress. Check back later","title":"[WIP] Getting started with PID"},{"location":"programming/pneumatics.html","text":"[WIP] Using Pneumatics # Check the air pressure Overview # This section will help you learn to program pneumatic for your robot. For this section we are going to create a new subsystem called shooter and add one pneumatic piston (cylinder) which will be used for changing the pitch of the shooter. See table of contents for a breakdown of this section. Background info # What Are Pneumatics # You have probably heard of hydraulics before (which is based on water pressure). Pneumatics are essentially the same but with air pressure. Unlike motors and gears which are commonly infinitely positional, pneumatic cylinders are typically dual-positional or sometimes tri-positional. Pneumatic cylinders are actuated through devices called solenoids. Solenoids are used to control pneumatic pistons (air cylinders) similar to how Talons control motors. What Are Solenoids # Cylinders are actuated with either single solenoids or double solenoids . A single solenoid actuates with one air line, using air to switch to and hold the extended state and releasing air (sometimes paired with a spring) to allow the cylinder to return to the retracted state. A single solenoid valve has one solenoid, and shifts when voltage is CONSTANTLY supplied to that solenoid. When voltage is removed, it shifts back to a \"home\" position. A double solenoid actuates with two air lines, using air to switch and hold states between retracted and extended. A double solenoid has two solenoids, and when voltage is supplied to one (and not the other) the valve shifts. Solenoids are connected to the Pneumatics Control Module (PCM) The PCM is connected to the roboRIO via the CAN bus. Programming Solenoids # For this section we are going to create a new subsystem called shooter and add one pneumatic piston (cylinder) which will be used for changing the pitch of the shooter. See Creating a New Subsystem . What will be added to the Shooter subsystem # 1) Create a new Shooter subsystem. It will be controlled through a double solenoid. We are going to create a DoubleSolenoid named pitchSolenoid. DoubleSolenoids have 2 controllable positions (deployed(forward) and retracted(reverse)). The DoubleSolenoid constructor takes 2 parameters - (new DoubleSolenoid(port1, port2) ) Port 1 and Port 2 refer to Forward control and Reverse control ports on the PCM. Like all ports we use, we will store this in the RobotMap. 2) Create your DoubleSolenoid named pitchSolenoid now using the same technique used to create a talon but replacing Talon with DoubleSolenoid. (For single solenoids just use Solenoid). Example Your full Shooter.java should look like this package frc.robot.subsystems; import edu.wpi.first.wpilibj.DoubleSolenoid; import edu.wpi.first.wpilibj.command.Subsystem; import frc.robot.RobotMap; /** * Add your docs here. */ public class Shooter extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. DoubleSolenoid pitchSolenoid = null; public Shooter() { pitchSolenoid = new DoubleSolenoid(RobotMap.SHOOTER_PITCH_SOLENOID_DEPLOY, RobotMap.SHOOTER_PITCH_SOLENOID_RETRACT); } @Override public void initDefaultCommand() { // Set the default command for a subsystem here. // setDefaultCommand(new MySpecialCommand()); } } The code you typed in Robot.java should be this Outside robotInit public static Shooter m_shooter = null; Inside robotInit m_shooter = new Shooter(); The code you typed in RobotMap.java should be this // Solenoids public static final int SHOOTER_PITCH_SOLENOID_DEPLOY = 0; public static final int SHOOTER_PITCH_SOLENOID_RETRACT = 1; Creating Pitch Up/Down Methods # 1) Create a public void method called pitchUp. 2) Inside type: pitchSolenoid.set(Value.kForward); This sets the value of the solenoid to forward (deployed) !!! Note if you wanted multiple solenoids to deploy at the same time also have them do .set(Value.kForward); 3) Do the same for the pitchDown method but change kForward to kReverse . Example The code you typed should be this public void pitchUp(){ pitchSolenoid.set(Value.kForward); } public void pitchDown(){ pitchSolenoid.set(Value.kForward); } Creating The Commands to Use Pneumatics # Creating Deploy/Retract Instant Commands # Now that we have created the methods we must create commands to use them. Since changing the state of a solenoid only requires us to send a signal once (not continuously) we will create an InstantCommand instead of a Command InstantCommands work the same as regular commands but hide everything except for initialize(). (InstantCommand extends Command) Internally, they set isFinished to return always true so execute never runs. 1) Create a new InstantCommand called ShooterUp Alternatively: Create a regular Command and set isFinished to true 2) In the constructor adds requires(Robot.m_shooter) 3) In initialize() add our newly created method pitchUp method 4) Repeat steps for ShooterDown command but change pitchUp* to **pitchDown Example Your full ShooterUp.java should look like this package frc.robot.commands; import edu.wpi.first.wpilibj.command.InstantCommand; import frc.robot.Robot; /** * Add your docs here. */ public class ShooterUp extends InstantCommand { /** * Add your docs here. */ public ShooterUp() { super(); // Use requires() here to declare subsystem dependencies // eg. requires(chassis); requires(Robot.m_shooter); } // Called once when the command executes @Override protected void initialize() { Robot.m_shooter.pitchUp(); } } Your full ShooterDown.java should look like this package frc.robot.commands; import edu.wpi.first.wpilibj.command.InstantCommand; import frc.robot.Robot; /** * Add your docs here. */ public class ShooterDown extends InstantCommand { /** * Add your docs here. */ public ShooterDown() { super(); // Use requires() here to declare subsystem dependencies // eg. requires(chassis); requires(Robot.m_shooter); } // Called once when the command executes @Override protected void initialize() { Robot.m_shooter.pitchDown(); } } Mapping Commands to Buttons # Creating Joystick Buttons # Now that we have created our ShooterUp and ShooterDown commands we need a way to run them. Lets map them to buttons on our controller! 1) Open OI.java 2) Under our created joystick we will create Button variables and assign them to a button on our joystick 3) Type: Button D1 = new JoystickButton(driverController, 1); This creates a new Button named D1 (D representing driverController and 1 representing the button number) and sets it as a JoystickButton on the controller \u2018driverController\u2019 and button value 1 (this can be found in the Driverstation software). 4) Do this for the rest of the buttons on your controller. Example Your full OI.Java should look like this package frc.robot; import edu.wpi.first.wpilibj.Joystick; import edu.wpi.first.wpilibj.buttons.Button; import edu.wpi.first.wpilibj.buttons.JoystickButton; /** * This class is the glue that binds the controls on the physical operator * interface to the commands and command groups that allow control of the robot. */ public class OI { public Joystick driverController = new Joystick(RobotMap.OI_DRIVER_CONTROLLER); Button D1 = new JoystickButton(driverController, 1); Button D2 = new JoystickButton(driverController, 2); Button D3 = new JoystickButton(driverController, 3); Button D4 = new JoystickButton(driverController, 4); Button D5 = new JoystickButton(driverController, 5); Button D6 = new JoystickButton(driverController, 6); Button D7 = new JoystickButton(driverController, 7); Button D8 = new JoystickButton(driverController, 8); Button D9 = new JoystickButton(driverController, 9); Button D10 = new JoystickButton(driverController, 10); } Mapping Joystick Buttons # Now that we have created the buttons in the code we can map certain commands to them. 1) Create a constructor for OI 2) In the constructor type: D1.whenPressed(new ShooterUp()); This means when the button D1 is pressed it runs the ShooterUp command and deploys our pneumatic piston. There are other types of activations for buttons besides whenPressed like: whenRelease, whileHeld, etc . 3) Create a whenPressed button for ShooterDown as well Example The code you typed should be this public OI(){ D1.whenPressed(new ShooterUp()); D2.whenPressed(new ShooterDown()); } Tip You can change your import at the top of the file from: import frc.robot.commands.ShooterUp; to import frc.robot.commands.*; The asterisk (wildcard) makes it so all files in the .command package (folder) are imported. This way you only have to import once.","title":"[WIP] Using Pneumatics"},{"location":"programming/pneumatics.html#wip-using-pneumatics","text":"Check the air pressure","title":"[WIP] Using Pneumatics"},{"location":"programming/pneumatics.html#overview","text":"This section will help you learn to program pneumatic for your robot. For this section we are going to create a new subsystem called shooter and add one pneumatic piston (cylinder) which will be used for changing the pitch of the shooter. See table of contents for a breakdown of this section.","title":"Overview"},{"location":"programming/pneumatics.html#background-info","text":"","title":"Background info"},{"location":"programming/pneumatics.html#what-are-pneumatics","text":"You have probably heard of hydraulics before (which is based on water pressure). Pneumatics are essentially the same but with air pressure. Unlike motors and gears which are commonly infinitely positional, pneumatic cylinders are typically dual-positional or sometimes tri-positional. Pneumatic cylinders are actuated through devices called solenoids. Solenoids are used to control pneumatic pistons (air cylinders) similar to how Talons control motors.","title":"What Are Pneumatics"},{"location":"programming/pneumatics.html#what-are-solenoids","text":"Cylinders are actuated with either single solenoids or double solenoids . A single solenoid actuates with one air line, using air to switch to and hold the extended state and releasing air (sometimes paired with a spring) to allow the cylinder to return to the retracted state. A single solenoid valve has one solenoid, and shifts when voltage is CONSTANTLY supplied to that solenoid. When voltage is removed, it shifts back to a \"home\" position. A double solenoid actuates with two air lines, using air to switch and hold states between retracted and extended. A double solenoid has two solenoids, and when voltage is supplied to one (and not the other) the valve shifts. Solenoids are connected to the Pneumatics Control Module (PCM) The PCM is connected to the roboRIO via the CAN bus.","title":"What Are Solenoids"},{"location":"programming/pneumatics.html#programming-solenoids","text":"For this section we are going to create a new subsystem called shooter and add one pneumatic piston (cylinder) which will be used for changing the pitch of the shooter. See Creating a New Subsystem .","title":"Programming Solenoids"},{"location":"programming/pneumatics.html#what-will-be-added-to-the-shooter-subsystem","text":"1) Create a new Shooter subsystem. It will be controlled through a double solenoid. We are going to create a DoubleSolenoid named pitchSolenoid. DoubleSolenoids have 2 controllable positions (deployed(forward) and retracted(reverse)). The DoubleSolenoid constructor takes 2 parameters - (new DoubleSolenoid(port1, port2) ) Port 1 and Port 2 refer to Forward control and Reverse control ports on the PCM. Like all ports we use, we will store this in the RobotMap. 2) Create your DoubleSolenoid named pitchSolenoid now using the same technique used to create a talon but replacing Talon with DoubleSolenoid. (For single solenoids just use Solenoid). Example Your full Shooter.java should look like this package frc.robot.subsystems; import edu.wpi.first.wpilibj.DoubleSolenoid; import edu.wpi.first.wpilibj.command.Subsystem; import frc.robot.RobotMap; /** * Add your docs here. */ public class Shooter extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. DoubleSolenoid pitchSolenoid = null; public Shooter() { pitchSolenoid = new DoubleSolenoid(RobotMap.SHOOTER_PITCH_SOLENOID_DEPLOY, RobotMap.SHOOTER_PITCH_SOLENOID_RETRACT); } @Override public void initDefaultCommand() { // Set the default command for a subsystem here. // setDefaultCommand(new MySpecialCommand()); } } The code you typed in Robot.java should be this Outside robotInit public static Shooter m_shooter = null; Inside robotInit m_shooter = new Shooter(); The code you typed in RobotMap.java should be this // Solenoids public static final int SHOOTER_PITCH_SOLENOID_DEPLOY = 0; public static final int SHOOTER_PITCH_SOLENOID_RETRACT = 1;","title":"What will be added to the Shooter subsystem"},{"location":"programming/pneumatics.html#creating-pitch-updown-methods","text":"1) Create a public void method called pitchUp. 2) Inside type: pitchSolenoid.set(Value.kForward); This sets the value of the solenoid to forward (deployed) !!! Note if you wanted multiple solenoids to deploy at the same time also have them do .set(Value.kForward); 3) Do the same for the pitchDown method but change kForward to kReverse . Example The code you typed should be this public void pitchUp(){ pitchSolenoid.set(Value.kForward); } public void pitchDown(){ pitchSolenoid.set(Value.kForward); }","title":"Creating Pitch Up/Down Methods"},{"location":"programming/pneumatics.html#creating-the-commands-to-use-pneumatics","text":"","title":"Creating The Commands to Use Pneumatics"},{"location":"programming/pneumatics.html#creating-deployretract-instant-commands","text":"Now that we have created the methods we must create commands to use them. Since changing the state of a solenoid only requires us to send a signal once (not continuously) we will create an InstantCommand instead of a Command InstantCommands work the same as regular commands but hide everything except for initialize(). (InstantCommand extends Command) Internally, they set isFinished to return always true so execute never runs. 1) Create a new InstantCommand called ShooterUp Alternatively: Create a regular Command and set isFinished to true 2) In the constructor adds requires(Robot.m_shooter) 3) In initialize() add our newly created method pitchUp method 4) Repeat steps for ShooterDown command but change pitchUp* to **pitchDown Example Your full ShooterUp.java should look like this package frc.robot.commands; import edu.wpi.first.wpilibj.command.InstantCommand; import frc.robot.Robot; /** * Add your docs here. */ public class ShooterUp extends InstantCommand { /** * Add your docs here. */ public ShooterUp() { super(); // Use requires() here to declare subsystem dependencies // eg. requires(chassis); requires(Robot.m_shooter); } // Called once when the command executes @Override protected void initialize() { Robot.m_shooter.pitchUp(); } } Your full ShooterDown.java should look like this package frc.robot.commands; import edu.wpi.first.wpilibj.command.InstantCommand; import frc.robot.Robot; /** * Add your docs here. */ public class ShooterDown extends InstantCommand { /** * Add your docs here. */ public ShooterDown() { super(); // Use requires() here to declare subsystem dependencies // eg. requires(chassis); requires(Robot.m_shooter); } // Called once when the command executes @Override protected void initialize() { Robot.m_shooter.pitchDown(); } }","title":"Creating Deploy/Retract Instant Commands"},{"location":"programming/pneumatics.html#mapping-commands-to-buttons","text":"","title":"Mapping Commands to Buttons"},{"location":"programming/pneumatics.html#creating-joystick-buttons","text":"Now that we have created our ShooterUp and ShooterDown commands we need a way to run them. Lets map them to buttons on our controller! 1) Open OI.java 2) Under our created joystick we will create Button variables and assign them to a button on our joystick 3) Type: Button D1 = new JoystickButton(driverController, 1); This creates a new Button named D1 (D representing driverController and 1 representing the button number) and sets it as a JoystickButton on the controller \u2018driverController\u2019 and button value 1 (this can be found in the Driverstation software). 4) Do this for the rest of the buttons on your controller. Example Your full OI.Java should look like this package frc.robot; import edu.wpi.first.wpilibj.Joystick; import edu.wpi.first.wpilibj.buttons.Button; import edu.wpi.first.wpilibj.buttons.JoystickButton; /** * This class is the glue that binds the controls on the physical operator * interface to the commands and command groups that allow control of the robot. */ public class OI { public Joystick driverController = new Joystick(RobotMap.OI_DRIVER_CONTROLLER); Button D1 = new JoystickButton(driverController, 1); Button D2 = new JoystickButton(driverController, 2); Button D3 = new JoystickButton(driverController, 3); Button D4 = new JoystickButton(driverController, 4); Button D5 = new JoystickButton(driverController, 5); Button D6 = new JoystickButton(driverController, 6); Button D7 = new JoystickButton(driverController, 7); Button D8 = new JoystickButton(driverController, 8); Button D9 = new JoystickButton(driverController, 9); Button D10 = new JoystickButton(driverController, 10); }","title":"Creating Joystick Buttons"},{"location":"programming/pneumatics.html#mapping-joystick-buttons","text":"Now that we have created the buttons in the code we can map certain commands to them. 1) Create a constructor for OI 2) In the constructor type: D1.whenPressed(new ShooterUp()); This means when the button D1 is pressed it runs the ShooterUp command and deploys our pneumatic piston. There are other types of activations for buttons besides whenPressed like: whenRelease, whileHeld, etc . 3) Create a whenPressed button for ShooterDown as well Example The code you typed should be this public OI(){ D1.whenPressed(new ShooterUp()); D2.whenPressed(new ShooterDown()); } Tip You can change your import at the top of the file from: import frc.robot.commands.ShooterUp; to import frc.robot.commands.*; The asterisk (wildcard) makes it so all files in the .command package (folder) are imported. This way you only have to import once.","title":"Mapping Joystick Buttons"},{"location":"programming/robotpreferences.html","text":"[WIP] Using RobotPreferences # Overview # In this section we will be going over Creating and using RobotPreferences in shuffleboard How to convert encoder counts to inches What Are RobotPreferences # On SmartDashboard or ShuffleBoard there is a widget called Robot Preferences that can store variables that can be quickly changed For example you might have a variable that changes PID values which can be changed from Robot Preferences on SmartDashboard/ShuffleBoard For this section of our tutorial we will create a robot preference called driveEncoderCountsPerFoot Creating RobotPreferences # 1) Create a new empty class called RobotPreferences This is where we store all of our RobotPreferences to access anywhere If we want to use a RobotPreference we call RobotPreferences.preferenceName() 2) Inside the constructor type: public static double driveEncoderCountsPerFoot(){ return Preferences.getInstance().getDouble(\u201cdriveEncoderCountsPerFoot\u201d, 1.0); } The format for creating a RobotPreference is public static variableType preferenceName(){ return Preferences.getInstance().getVariableType(\"preferenceName\", value); Example Your full RobotPreferences.java should look like this package frc.robot; import edu.wpi.first.wpilibj.Preferences; /** * Add your docs here. */ public class RobotPreferences { // Drivetrain /** * Default value is 1.0 */ public static double driveEncoderCountsPerFoot() { return Preferences.getInstance().getDouble(\"driveEncoderCountsPerFoot\", 1.0); } } Creating getDriveEncoderDistance Method # We will use this RobotPreference to help us create a method that can keep track of the distance our robot has driven in inches 1) Create a method called getDriveEncoderDistance inside of Drivetrain 2) Inside type: return (getDriveEncoderCount() / RobotPreferences.driveEncoderCountsPerFoot()) * 12; This will divide the current encoder count by however many counts there are in a foot then multiply that number by 12 to give us the encoder distance in inches Note You may need to invert this value if your encoder counts backward when the robot is driving forward Example The code you typed should be this public double getDriveEncoderDistance() { return (getDriveEncoderCount() / RobotPreferences.driveEncoderCountsPerFoot()) * 12; } 3) Add the method to the update method in Telemetry Using RobotPreferences # After deploying the code to your robot find the RobotPreferences widget and add it to your page Click the add button and enter the string of the RobotPreference and its type (doubles and ints are numbers) If you double click on the preference value you will notice that you can change its value If you change a preference value it will update immediately Tip If you want to save your robot preference values that you've changed make sure you hardcode them in RobotPreferences.java later or take a picture if you want to use them again later Measuring Distance Using Encoders # Right now the encoders tell us distance in terms of encoder counts We will use our driveEncoderCountsPerFoot preference to save how many counts there are when the robot drives 1 foot 1) Move the wheel on your robot with the Drivetrain encoder attached 1 foot or drive your robot 1 foot 2) Read how many counts your encoder has in the Drive Encoder Count window If you want to measure again press the Reset Drive Encoder command button to reset the Drivetrain encoder count 3) Change the value of driveEncoderCountsPerFoot in the widget to this number 4) Reset the Drivetrain encoder and move the wheel 1 foot or drive the robot 1 foot again 5) Make sure your Drive Encoder Distance window reads approximately 12 (this is in inches) If not repeat these steps again 6) Save your RobotPreferences widget with this value 7) Hardcode this value in RobotPreferences.java in the driveEncoderCountsPerFoot method incase you cannot recover your RobotPreferences save","title":"[WIP] Using RobotPreferences"},{"location":"programming/robotpreferences.html#wip-using-robotpreferences","text":"","title":"[WIP] Using RobotPreferences"},{"location":"programming/robotpreferences.html#overview","text":"In this section we will be going over Creating and using RobotPreferences in shuffleboard How to convert encoder counts to inches","title":"Overview"},{"location":"programming/robotpreferences.html#what-are-robotpreferences","text":"On SmartDashboard or ShuffleBoard there is a widget called Robot Preferences that can store variables that can be quickly changed For example you might have a variable that changes PID values which can be changed from Robot Preferences on SmartDashboard/ShuffleBoard For this section of our tutorial we will create a robot preference called driveEncoderCountsPerFoot","title":"What Are RobotPreferences"},{"location":"programming/robotpreferences.html#creating-robotpreferences","text":"1) Create a new empty class called RobotPreferences This is where we store all of our RobotPreferences to access anywhere If we want to use a RobotPreference we call RobotPreferences.preferenceName() 2) Inside the constructor type: public static double driveEncoderCountsPerFoot(){ return Preferences.getInstance().getDouble(\u201cdriveEncoderCountsPerFoot\u201d, 1.0); } The format for creating a RobotPreference is public static variableType preferenceName(){ return Preferences.getInstance().getVariableType(\"preferenceName\", value); Example Your full RobotPreferences.java should look like this package frc.robot; import edu.wpi.first.wpilibj.Preferences; /** * Add your docs here. */ public class RobotPreferences { // Drivetrain /** * Default value is 1.0 */ public static double driveEncoderCountsPerFoot() { return Preferences.getInstance().getDouble(\"driveEncoderCountsPerFoot\", 1.0); } }","title":"Creating RobotPreferences"},{"location":"programming/robotpreferences.html#creating-getdriveencoderdistance-method","text":"We will use this RobotPreference to help us create a method that can keep track of the distance our robot has driven in inches 1) Create a method called getDriveEncoderDistance inside of Drivetrain 2) Inside type: return (getDriveEncoderCount() / RobotPreferences.driveEncoderCountsPerFoot()) * 12; This will divide the current encoder count by however many counts there are in a foot then multiply that number by 12 to give us the encoder distance in inches Note You may need to invert this value if your encoder counts backward when the robot is driving forward Example The code you typed should be this public double getDriveEncoderDistance() { return (getDriveEncoderCount() / RobotPreferences.driveEncoderCountsPerFoot()) * 12; } 3) Add the method to the update method in Telemetry","title":"Creating getDriveEncoderDistance Method"},{"location":"programming/robotpreferences.html#using-robotpreferences","text":"After deploying the code to your robot find the RobotPreferences widget and add it to your page Click the add button and enter the string of the RobotPreference and its type (doubles and ints are numbers) If you double click on the preference value you will notice that you can change its value If you change a preference value it will update immediately Tip If you want to save your robot preference values that you've changed make sure you hardcode them in RobotPreferences.java later or take a picture if you want to use them again later","title":"Using RobotPreferences"},{"location":"programming/robotpreferences.html#measuring-distance-using-encoders","text":"Right now the encoders tell us distance in terms of encoder counts We will use our driveEncoderCountsPerFoot preference to save how many counts there are when the robot drives 1 foot 1) Move the wheel on your robot with the Drivetrain encoder attached 1 foot or drive your robot 1 foot 2) Read how many counts your encoder has in the Drive Encoder Count window If you want to measure again press the Reset Drive Encoder command button to reset the Drivetrain encoder count 3) Change the value of driveEncoderCountsPerFoot in the widget to this number 4) Reset the Drivetrain encoder and move the wheel 1 foot or drive the robot 1 foot again 5) Make sure your Drive Encoder Distance window reads approximately 12 (this is in inches) If not repeat these steps again 6) Save your RobotPreferences widget with this value 7) Hardcode this value in RobotPreferences.java in the driveEncoderCountsPerFoot method incase you cannot recover your RobotPreferences save","title":"Measuring Distance Using Encoders"},{"location":"programming/shuffleboard.html","text":"[WIP] Using Shuffleboard # Overview # In this section we will be going over Using and organizing the Shuffleboard Creating the Telemetry subsystem and adding buttons and data to be viewed in Shuffleboard What is Shuffleboard # Shuffleboard is one of the boards the driverstation displays robot data with It can have widgets like graphs, camera streams, and meters Unique to shuffleboard is the ability to have tabs for different boards What is Telemetry # Telemetry is where we add data to be viewed or command buttons on shuffleboard or smartdashboard For this section of our tutorial we will be adding switch and encoder data to shuffleboard Creating the Telemetry Subsystem # 1) Create a new Subsystem called Telemetry 2) Create a constructor for the Telemetry class The constructor is where we will create buttons for shuffleboard 3) Inside type: SmartDashboard.putData(\u201cReset Drive Encoder\u201d, new DriveResetEncoder()); 4) Create a public method called update This method will run periodically in Robot.java to update sensor data on shuffleboard 5) Inside type: SmartDashboard.putNumber(\u201cDrivetrain Encoder Count\u201d, Robot.m_drivetrain.getDriveEncoderCount()); 6) Do the same for the getDriveEncoderDistance method 7) Try adding the Shooter Subsystem commands and sensor methods where they should be Example Your full Telemetry.java should look like this package frc.robot.subsystems; import edu.wpi.first.wpilibj.command.Subsystem; import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard; import frc.robot.Robot; import frc.robot.commands.*; /** * Add your docs here. */ public class Telemetry extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. public Telemetry() { // Drivetrain SmartDashboard.putData(\"Reset Drive Encoder\", new DriveResetEncoder()); // Shooter SmartDashboard.putData(\"Shooter Up\", new ShooterUp()); SmartDashboard.putData(\"Shooter Down\", new ShooterDown()); SmartDashboard.putData(\"Shooter Up Auto\", new ShooterUpAuto()); } public void update() { // Drivetrain SmartDashboard.putNumber(\"Drive Encoder Count\", Robot.m_drivetrain.getDriveEncoderCount()); // Shooter SmartDashboard.putBoolean(\"Shooter Switch\", Robot.m_shooter.isShooterSwitchClosed()); } @Override public void initDefaultCommand() { // Set the default command for a subsystem here. // setDefaultCommand(new MySpecialCommand()); } } Adding The Telemetry Subsystem to Robot.java # 1) When adding Telemetry to Robot.java , in robotInit we must add Telemetry after the other subsystems This is because the Telemetry subsystem relies on methods that are created in other subsystems before it It can be added before or after OI since they don\u2019t use methods from each other 2) It is important that we add the update method to disabledPeriodic, autonomousPeriodic , and teleopPeriodic so that the Shuffleboard is always being updated with information on our sensors. Example The code you typed before robotInit should be this public static Telemetry m_telemetry; The code you typed in robotInit should be this m_telemetry = new Telemetry(); //This must be initialized after all other robot subsystems The code you typed in disabledPeriodic, autonomousPeriodic , and teleopPeriodic should be this Robot.m_telemetry.update(); Testing Shuffleboard # After saving and deploying code, open the driver station Click the gear on the left side and configure your team number and set the dashboard type to \u201cShuffleBoard\u201d If you are still connected to the robot you should see boxes for the buttons and data we added in Telemetry Using Shuffleboard #","title":"[WIP] Using Shuffleboard"},{"location":"programming/shuffleboard.html#wip-using-shuffleboard","text":"","title":"[WIP] Using Shuffleboard"},{"location":"programming/shuffleboard.html#overview","text":"In this section we will be going over Using and organizing the Shuffleboard Creating the Telemetry subsystem and adding buttons and data to be viewed in Shuffleboard","title":"Overview"},{"location":"programming/shuffleboard.html#what-is-shuffleboard","text":"Shuffleboard is one of the boards the driverstation displays robot data with It can have widgets like graphs, camera streams, and meters Unique to shuffleboard is the ability to have tabs for different boards","title":"What is Shuffleboard"},{"location":"programming/shuffleboard.html#what-is-telemetry","text":"Telemetry is where we add data to be viewed or command buttons on shuffleboard or smartdashboard For this section of our tutorial we will be adding switch and encoder data to shuffleboard","title":"What is Telemetry"},{"location":"programming/shuffleboard.html#creating-the-telemetry-subsystem","text":"1) Create a new Subsystem called Telemetry 2) Create a constructor for the Telemetry class The constructor is where we will create buttons for shuffleboard 3) Inside type: SmartDashboard.putData(\u201cReset Drive Encoder\u201d, new DriveResetEncoder()); 4) Create a public method called update This method will run periodically in Robot.java to update sensor data on shuffleboard 5) Inside type: SmartDashboard.putNumber(\u201cDrivetrain Encoder Count\u201d, Robot.m_drivetrain.getDriveEncoderCount()); 6) Do the same for the getDriveEncoderDistance method 7) Try adding the Shooter Subsystem commands and sensor methods where they should be Example Your full Telemetry.java should look like this package frc.robot.subsystems; import edu.wpi.first.wpilibj.command.Subsystem; import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard; import frc.robot.Robot; import frc.robot.commands.*; /** * Add your docs here. */ public class Telemetry extends Subsystem { // Put methods for controlling this subsystem // here. Call these from Commands. public Telemetry() { // Drivetrain SmartDashboard.putData(\"Reset Drive Encoder\", new DriveResetEncoder()); // Shooter SmartDashboard.putData(\"Shooter Up\", new ShooterUp()); SmartDashboard.putData(\"Shooter Down\", new ShooterDown()); SmartDashboard.putData(\"Shooter Up Auto\", new ShooterUpAuto()); } public void update() { // Drivetrain SmartDashboard.putNumber(\"Drive Encoder Count\", Robot.m_drivetrain.getDriveEncoderCount()); // Shooter SmartDashboard.putBoolean(\"Shooter Switch\", Robot.m_shooter.isShooterSwitchClosed()); } @Override public void initDefaultCommand() { // Set the default command for a subsystem here. // setDefaultCommand(new MySpecialCommand()); } }","title":"Creating the Telemetry Subsystem"},{"location":"programming/shuffleboard.html#adding-the-telemetry-subsystem-to-robotjava","text":"1) When adding Telemetry to Robot.java , in robotInit we must add Telemetry after the other subsystems This is because the Telemetry subsystem relies on methods that are created in other subsystems before it It can be added before or after OI since they don\u2019t use methods from each other 2) It is important that we add the update method to disabledPeriodic, autonomousPeriodic , and teleopPeriodic so that the Shuffleboard is always being updated with information on our sensors. Example The code you typed before robotInit should be this public static Telemetry m_telemetry; The code you typed in robotInit should be this m_telemetry = new Telemetry(); //This must be initialized after all other robot subsystems The code you typed in disabledPeriodic, autonomousPeriodic , and teleopPeriodic should be this Robot.m_telemetry.update();","title":"Adding The Telemetry Subsystem to Robot.java"},{"location":"programming/shuffleboard.html#testing-shuffleboard","text":"After saving and deploying code, open the driver station Click the gear on the left side and configure your team number and set the dashboard type to \u201cShuffleBoard\u201d If you are still connected to the robot you should see boxes for the buttons and data we added in Telemetry","title":"Testing Shuffleboard"},{"location":"programming/shuffleboard.html#using-shuffleboard","text":"","title":"Using Shuffleboard"},{"location":"programming/super_core.html","text":"[WIP] Using SuperCORE # This page is currently a work in progress. Check back later","title":"[WIP] Using SuperCORE"},{"location":"programming/super_core.html#wip-using-supercore","text":"This page is currently a work in progress. Check back later","title":"[WIP] Using SuperCORE"},{"location":"programming/using_sensors.html","text":"[WIP] Using Sensors and Switches # Overview # In this section we will be going over Creating and using a switch in a shooter subsystem Create this subsystem now. (See Creating a New Subsystem ) Creating an encoder in the drivetrain subsystem (See creating a driving robot) What Are Sensors # There are different types of sensors that give feedback on different things (i.e. Encoders measure distance, switches detect contact, gyros give orientation). Most of these interface with the roboRIO through either the DIO, analog input, or custom electronics port. Programming Switches (i.e. Limit Switches) # 1) For this tutorial we are going to add a switch to a shooter subsystem to automatically change the pitch of the shooter Inside the shooter subsystem we are going to create a switch called shooterSwitch It will be created as a DigitalInput The DigitalInput constructor only takes 1 parameter - DigitalInput(port) The port refers to the port numbers on the RoboRIO\u2019s DIO Store the port in Constants Example The code you typed should be this DigitalInput shooterSwitch = null; In the constructor shooterSwitch = new DigitalInput(Constants.SHOOTER_SWITCH); In Constants.Java // Digital Inputs public static final int SHOOTER_SWITCH = 0; Creating isShooterSwitchClosed Method # 1) Create a public boolean method called isShooterSwitchClosed This method will tell us when the shooter switch is pressed 2) Inside type: return shooterSwitch.get(); Switches have 2 states: open and closed. Make sure you know which is true or false or you may have to invert the switch by rewiring or using the ! operator Example Your isShooterSwitchClosed() should look like this public boolean isShooterSwitchClosed() { return shooterSwitch.get(); } Full Shooter.java Example package frc.robot.subsystems; import edu.wpi.first.wpilibj.DigitalInput; import edu.wpi.first.wpilibj2.command.SubsystemBase; import frc.robot.Constants; public class Shooter extends SubsystemBase { /** * Creates a new Shooter. */ DigitalInput shooterSwitch = null; public Shooter() { shooterSwitch = new DigitalInput(Constants.SHOOTER_SWITCH); } public boolean isShooterSwitchClosed() { return shooterSwitch.get(); } @Override public void periodic() { // This method will be called once per scheduler run } } Creating ShooterUpAuto Command # We will create a command that gives an example of how a Shooter switch may be used 1) For this tutorial we will use the switch to create a button that automatically pitches the shooter up after the switch is pressed 2) Create a new command called ShooterUpAuto 3) In the constructor add requires(Robot.m_Shooter) 4) In isFinished return our isShooterSwitchClosed method we will not put anything in initialize or execute because we don't want anything to happen until the switch is closed 5) In end add our pitchUp method we will not put end in interrupted either because we only want to change the pitch of the shooter if the switch is closed Example Your full ShooterUpAuto.java should look like this package frc.robot.commands; import edu.wpi.first.wpilibj.command.Command; import frc.robot.Robot; public class ShooterUpAuto extends Command { public ShooterUpAuto() { // Use requires() here to declare subsystem dependencies // eg. requires(chassis); requires(Robot.m_shooter); } // Called just before this Command runs the first time @Override protected void initialize() { } // Called repeatedly when this Command is scheduled to run @Override protected void execute() { } // Make this return true when this Command no longer needs to run execute() @Override protected boolean isFinished() { return Robot.m_shooter.isShooterSwitchClosed(); } // Called once after isFinished returns true @Override protected void end() { Robot.m_shooter.pitchUp(); } // Called when another command which requires one or more of the same // subsystems is scheduled to run @Override protected void interrupted() { } } Mapping ShooterAutoUpCommand # To be able to test our command right now we can map it to a joystick button like we did our other Shooter commands It would be best to make it a whenPressed or whileHeld button whileHeld will run normally while the button is being held and be interrupted when released Example The code you typed should be this D3.whenPressed(new ShooterUpAuto()); Or this D3.whileHeld(new ShooterUpAuto()); Programming Encoders # 1) For this tutorial we are going to add a encoder to the Drivetrain subsystem to keep track of the distance the robot has driven 2) Inside the Drivetrain subsystem we are going to create an encoder called driveEncoder It will be created as an Encoder The Encoder constructor takes 2 parameters - (new Encoder(port1,port2)) These are DIO ports on the RoboRIO Store ports in Constants as DRIVE_ENCODER_A and B Example The code you typed outside the constructor should be this Encoder driveEncoder = null; Inside the constructor driveEncoder = new Encoder(Constants.DRIVETRAIN_ENCODER_A, Constants.DRIVETRAIN_ENCODER_B); Creating Drive Encoder Methods # 1) Create a public double method called getDriveEncoderCount 2) Inside type: return driveEncoder.get(); Encoders will return counts as an int Depending which direction the encoder shaft rotates the value will increase or decrease 3) Create a public method called resetDriveEncoderCount 4) Inside type: driveEncoder.reset(); This method will reset the drive encoder to zero which is useful for autonomous or when we use the robot as a ruler Example The code you typed should be this public double getDriveEncoderCount() { return driveEncoder.get(); } public void resetDriveEncoder() { driveEncoder.reset(); } Creating ResetDriveEncoder InstantCommand # We need to create a command to use the resetDriveEncoder method since it\u2019s a void method We will create a InstantCommand since we will only use it to reset the drive encoder 1) Create a new InstantCommand called DriveResetEncoder 2) In the constructor add requires(Robot.m_drivetrain) 3) In initialize() add our resetDriveEncoder method Example Your full DriveResetEncoder command should look like this package frc.robot.commands; import edu.wpi.first.wpilibj.command.InstantCommand; import frc.robot.Robot; /** * Add your docs here. */ public class DriveResetEncoder extends InstantCommand { /** * Add your docs here. */ public DriveResetEncoder() { super(); // Use requires() here to declare subsystem dependencies // eg. requires(chassis); requires(Robot.m_drivetrain); } // Called once when the command executes @Override protected void initialize() { Robot.m_drivetrain.resetDriveEncoder(); } }","title":"[WIP] Using Sensors and Switches"},{"location":"programming/using_sensors.html#wip-using-sensors-and-switches","text":"","title":"[WIP] Using Sensors and Switches"},{"location":"programming/using_sensors.html#overview","text":"In this section we will be going over Creating and using a switch in a shooter subsystem Create this subsystem now. (See Creating a New Subsystem ) Creating an encoder in the drivetrain subsystem (See creating a driving robot)","title":"Overview"},{"location":"programming/using_sensors.html#what-are-sensors","text":"There are different types of sensors that give feedback on different things (i.e. Encoders measure distance, switches detect contact, gyros give orientation). Most of these interface with the roboRIO through either the DIO, analog input, or custom electronics port.","title":"What Are Sensors"},{"location":"programming/using_sensors.html#programming-switches-ie-limit-switches","text":"1) For this tutorial we are going to add a switch to a shooter subsystem to automatically change the pitch of the shooter Inside the shooter subsystem we are going to create a switch called shooterSwitch It will be created as a DigitalInput The DigitalInput constructor only takes 1 parameter - DigitalInput(port) The port refers to the port numbers on the RoboRIO\u2019s DIO Store the port in Constants Example The code you typed should be this DigitalInput shooterSwitch = null; In the constructor shooterSwitch = new DigitalInput(Constants.SHOOTER_SWITCH); In Constants.Java // Digital Inputs public static final int SHOOTER_SWITCH = 0;","title":"Programming Switches (i.e. Limit Switches)"},{"location":"programming/using_sensors.html#creating-isshooterswitchclosed-method","text":"1) Create a public boolean method called isShooterSwitchClosed This method will tell us when the shooter switch is pressed 2) Inside type: return shooterSwitch.get(); Switches have 2 states: open and closed. Make sure you know which is true or false or you may have to invert the switch by rewiring or using the ! operator Example Your isShooterSwitchClosed() should look like this public boolean isShooterSwitchClosed() { return shooterSwitch.get(); } Full Shooter.java Example package frc.robot.subsystems; import edu.wpi.first.wpilibj.DigitalInput; import edu.wpi.first.wpilibj2.command.SubsystemBase; import frc.robot.Constants; public class Shooter extends SubsystemBase { /** * Creates a new Shooter. */ DigitalInput shooterSwitch = null; public Shooter() { shooterSwitch = new DigitalInput(Constants.SHOOTER_SWITCH); } public boolean isShooterSwitchClosed() { return shooterSwitch.get(); } @Override public void periodic() { // This method will be called once per scheduler run } }","title":"Creating isShooterSwitchClosed Method"},{"location":"programming/using_sensors.html#creating-shooterupauto-command","text":"We will create a command that gives an example of how a Shooter switch may be used 1) For this tutorial we will use the switch to create a button that automatically pitches the shooter up after the switch is pressed 2) Create a new command called ShooterUpAuto 3) In the constructor add requires(Robot.m_Shooter) 4) In isFinished return our isShooterSwitchClosed method we will not put anything in initialize or execute because we don't want anything to happen until the switch is closed 5) In end add our pitchUp method we will not put end in interrupted either because we only want to change the pitch of the shooter if the switch is closed Example Your full ShooterUpAuto.java should look like this package frc.robot.commands; import edu.wpi.first.wpilibj.command.Command; import frc.robot.Robot; public class ShooterUpAuto extends Command { public ShooterUpAuto() { // Use requires() here to declare subsystem dependencies // eg. requires(chassis); requires(Robot.m_shooter); } // Called just before this Command runs the first time @Override protected void initialize() { } // Called repeatedly when this Command is scheduled to run @Override protected void execute() { } // Make this return true when this Command no longer needs to run execute() @Override protected boolean isFinished() { return Robot.m_shooter.isShooterSwitchClosed(); } // Called once after isFinished returns true @Override protected void end() { Robot.m_shooter.pitchUp(); } // Called when another command which requires one or more of the same // subsystems is scheduled to run @Override protected void interrupted() { } }","title":"Creating ShooterUpAuto Command"},{"location":"programming/using_sensors.html#mapping-shooterautoupcommand","text":"To be able to test our command right now we can map it to a joystick button like we did our other Shooter commands It would be best to make it a whenPressed or whileHeld button whileHeld will run normally while the button is being held and be interrupted when released Example The code you typed should be this D3.whenPressed(new ShooterUpAuto()); Or this D3.whileHeld(new ShooterUpAuto());","title":"Mapping ShooterAutoUpCommand"},{"location":"programming/using_sensors.html#programming-encoders","text":"1) For this tutorial we are going to add a encoder to the Drivetrain subsystem to keep track of the distance the robot has driven 2) Inside the Drivetrain subsystem we are going to create an encoder called driveEncoder It will be created as an Encoder The Encoder constructor takes 2 parameters - (new Encoder(port1,port2)) These are DIO ports on the RoboRIO Store ports in Constants as DRIVE_ENCODER_A and B Example The code you typed outside the constructor should be this Encoder driveEncoder = null; Inside the constructor driveEncoder = new Encoder(Constants.DRIVETRAIN_ENCODER_A, Constants.DRIVETRAIN_ENCODER_B);","title":"Programming Encoders"},{"location":"programming/using_sensors.html#creating-drive-encoder-methods","text":"1) Create a public double method called getDriveEncoderCount 2) Inside type: return driveEncoder.get(); Encoders will return counts as an int Depending which direction the encoder shaft rotates the value will increase or decrease 3) Create a public method called resetDriveEncoderCount 4) Inside type: driveEncoder.reset(); This method will reset the drive encoder to zero which is useful for autonomous or when we use the robot as a ruler Example The code you typed should be this public double getDriveEncoderCount() { return driveEncoder.get(); } public void resetDriveEncoder() { driveEncoder.reset(); }","title":"Creating Drive Encoder Methods"},{"location":"programming/using_sensors.html#creating-resetdriveencoder-instantcommand","text":"We need to create a command to use the resetDriveEncoder method since it\u2019s a void method We will create a InstantCommand since we will only use it to reset the drive encoder 1) Create a new InstantCommand called DriveResetEncoder 2) In the constructor add requires(Robot.m_drivetrain) 3) In initialize() add our resetDriveEncoder method Example Your full DriveResetEncoder command should look like this package frc.robot.commands; import edu.wpi.first.wpilibj.command.InstantCommand; import frc.robot.Robot; /** * Add your docs here. */ public class DriveResetEncoder extends InstantCommand { /** * Add your docs here. */ public DriveResetEncoder() { super(); // Use requires() here to declare subsystem dependencies // eg. requires(chassis); requires(Robot.m_drivetrain); } // Called once when the command executes @Override protected void initialize() { Robot.m_drivetrain.resetDriveEncoder(); } }","title":"Creating ResetDriveEncoder InstantCommand"},{"location":"setup/3rd_party_libs.html","text":"","title":"3rd party libs"},{"location":"setup/imaging_roboRIO.html","text":"Imaging the roboRIO # Flashing the firmware Overview # Before we can deploy code to the robot, we must flash a software image on to the roboRIO and possibly update the firmware. This can be accomplished with the roboRIO imaging tool: IMPORTANT NOTE The FRC Game Tools (Windows Only) need to be installed to access the roboRIO imaging tool. Using the roboRIO imaging tool # Following the instructions linked below will explain how to image/update the roboRIO. For Windows ONLY: Official 2020 FRC roboRIO Imaging guide (Windows only)","title":"Imaging the roboRIO"},{"location":"setup/imaging_roboRIO.html#imaging-the-roborio","text":"Flashing the firmware","title":"Imaging the roboRIO"},{"location":"setup/imaging_roboRIO.html#overview","text":"Before we can deploy code to the robot, we must flash a software image on to the roboRIO and possibly update the firmware. This can be accomplished with the roboRIO imaging tool: IMPORTANT NOTE The FRC Game Tools (Windows Only) need to be installed to access the roboRIO imaging tool.","title":"Overview"},{"location":"setup/imaging_roboRIO.html#using-the-roborio-imaging-tool","text":"Following the instructions linked below will explain how to image/update the roboRIO. For Windows ONLY: Official 2020 FRC roboRIO Imaging guide (Windows only)","title":"Using the roboRIO imaging tool"},{"location":"setup/install_other.html","text":"Installing Other Software # Overview # There are other pieces of software necessary for programming a robot depending on your circumstances. If you are using Talon or Spark Max motor controllers, those have their own debugging tools that are necessary. If you plan on motion profiling for your drivetrain in autonomous, (check our [motion profiling tutorial] for more on that) you will need to download a pathing software as well. See table of contents for a breakdown of this section. Installing Pheonix software (for talon motor controllers) # If you are using Talons on your robot, the Pheonix tuner software is a must have. It allows you to deploy software updates, debug/test your talons, and name/organize your talons. Installing the Pheonix suite # For Windows ONLY: Download link for CTRE Framework (next to 'Installer') Installing Spark Max Client # If you are using Spark Max motor controllers on your robot, the Spark Max tuner software is a must have. It allows you to deploy software updates, debug/test your Spark maxes, and name/organize your Spark Maxes. Installing the Spark Max Client # For Windows ONLY: Download Spark Max Client (click 'Download Latest SPARK MAX Client) Installing PathPlanner # In order to utilize motion profiling on a drivetrain, it is extremely helpful to have a tool such as Pathplanner. Pathplanner allows for seamless creation and deployment of motion profiles from your laptop to your robot, and has a nice interface for doing so. There are other available tools we may add in the future if pathplanner does not suit your needs, but we at 3255 found it comprehensive for our motion profiling needs (note, this software is only for driving in autonomous, it is likely not useful for other mechanisms). Installing Pathplanner # For Windows ONLY: Pathplanner Github (to install, click on the latest version under releases on the right)","title":"Installing Other Software"},{"location":"setup/install_other.html#installing-other-software","text":"","title":"Installing Other Software"},{"location":"setup/install_other.html#overview","text":"There are other pieces of software necessary for programming a robot depending on your circumstances. If you are using Talon or Spark Max motor controllers, those have their own debugging tools that are necessary. If you plan on motion profiling for your drivetrain in autonomous, (check our [motion profiling tutorial] for more on that) you will need to download a pathing software as well. See table of contents for a breakdown of this section.","title":"Overview"},{"location":"setup/install_other.html#installing-pheonix-software-for-talon-motor-controllers","text":"If you are using Talons on your robot, the Pheonix tuner software is a must have. It allows you to deploy software updates, debug/test your talons, and name/organize your talons.","title":"Installing Pheonix software (for talon motor controllers)"},{"location":"setup/install_other.html#installing-the-pheonix-suite","text":"For Windows ONLY: Download link for CTRE Framework (next to 'Installer')","title":"Installing the Pheonix suite"},{"location":"setup/install_other.html#installing-spark-max-client","text":"If you are using Spark Max motor controllers on your robot, the Spark Max tuner software is a must have. It allows you to deploy software updates, debug/test your Spark maxes, and name/organize your Spark Maxes.","title":"Installing Spark Max Client"},{"location":"setup/install_other.html#installing-the-spark-max-client","text":"For Windows ONLY: Download Spark Max Client (click 'Download Latest SPARK MAX Client)","title":"Installing the Spark Max Client"},{"location":"setup/install_other.html#installing-pathplanner","text":"In order to utilize motion profiling on a drivetrain, it is extremely helpful to have a tool such as Pathplanner. Pathplanner allows for seamless creation and deployment of motion profiles from your laptop to your robot, and has a nice interface for doing so. There are other available tools we may add in the future if pathplanner does not suit your needs, but we at 3255 found it comprehensive for our motion profiling needs (note, this software is only for driving in autonomous, it is likely not useful for other mechanisms).","title":"Installing PathPlanner"},{"location":"setup/install_other.html#installing-pathplanner_1","text":"For Windows ONLY: Pathplanner Github (to install, click on the latest version under releases on the right)","title":"Installing Pathplanner"},{"location":"setup/install_software.html","text":"Installing Necessary Software # Lets get started Overview # Before we can start programing a robot we must install the necessary software for programming and driving the robot. See table of contents for a breakdown of this section. Tip You can install both the Development Tools and the FRC Game Tools on the same computer or separate computers. However many teams (3255 included) have a development laptop (with both) and a dedicated driverstation laptop (with only the FRC Game Tools) that often stays disconnected from the internet. Installing Java Development Tools # If all you are doing is writing and deploying code to a robot, all you need are the development tools. Following the instructions linked below will get you set up with a development environment and get you setup with all the tools necessary to program a robot. Installing Java and Visual Studio Code (VSCode) # For Windows, macOS, or Linux: Official FRC installation guide (Windows, macOS, or Linux) IMPORTANT NOTE These tools only allow you to program and deploy code to an already imaged roboRIO. They do not allow you to drive the robot or image/update the roboRIO. To accomplish those tasks you must install the FRC Game Tools . Installing the FRC Game Tools # If all you are doing is driving an already programmed robot or imaging/updating the roboRIO all you need is the FRC Game Tools. Following the instructions linked below will get you set up with the tools to drive the robot and image/update the roboRIO. Installing the Driverstation software and roboRIO imaging tool # For Windows ONLY: Official FRC installation guide (Windows only) IMPORTANT NOTE These tools only allow you to drive the robot and image/update a roboRIO. They do not allow you to program the robot. To accomplish those tasks you must install the Java Development Tools . Installing the FRC Radio Configuration Utility # In order to enable wireless connectivity to the robot outside of FRC events or to allow connectivity to other network attached devices (i.e.Limelight Vision Camera), you must configure the robot's radio. Following the instructions linked below will get you set up with the Radio Configuration Utility and how to program the radio. Installing the Radio Configuration Utility and Programming the Radio # For Windows ONLY: Official FRC Radio Configuration Utility and Use guide (Windows only)","title":"Installing Necessary Software"},{"location":"setup/install_software.html#installing-necessary-software","text":"Lets get started","title":"Installing Necessary Software"},{"location":"setup/install_software.html#overview","text":"Before we can start programing a robot we must install the necessary software for programming and driving the robot. See table of contents for a breakdown of this section. Tip You can install both the Development Tools and the FRC Game Tools on the same computer or separate computers. However many teams (3255 included) have a development laptop (with both) and a dedicated driverstation laptop (with only the FRC Game Tools) that often stays disconnected from the internet.","title":"Overview"},{"location":"setup/install_software.html#installing-java-development-tools","text":"If all you are doing is writing and deploying code to a robot, all you need are the development tools. Following the instructions linked below will get you set up with a development environment and get you setup with all the tools necessary to program a robot.","title":"Installing Java Development Tools"},{"location":"setup/install_software.html#installing-java-and-visual-studio-code-vscode","text":"For Windows, macOS, or Linux: Official FRC installation guide (Windows, macOS, or Linux) IMPORTANT NOTE These tools only allow you to program and deploy code to an already imaged roboRIO. They do not allow you to drive the robot or image/update the roboRIO. To accomplish those tasks you must install the FRC Game Tools .","title":"Installing Java and Visual Studio Code (VSCode)"},{"location":"setup/install_software.html#installing-the-frc-game-tools","text":"If all you are doing is driving an already programmed robot or imaging/updating the roboRIO all you need is the FRC Game Tools. Following the instructions linked below will get you set up with the tools to drive the robot and image/update the roboRIO.","title":"Installing the FRC Game Tools"},{"location":"setup/install_software.html#installing-the-driverstation-software-and-roborio-imaging-tool","text":"For Windows ONLY: Official FRC installation guide (Windows only) IMPORTANT NOTE These tools only allow you to drive the robot and image/update a roboRIO. They do not allow you to program the robot. To accomplish those tasks you must install the Java Development Tools .","title":"Installing the Driverstation software and roboRIO imaging tool"},{"location":"setup/install_software.html#installing-the-frc-radio-configuration-utility","text":"In order to enable wireless connectivity to the robot outside of FRC events or to allow connectivity to other network attached devices (i.e.Limelight Vision Camera), you must configure the robot's radio. Following the instructions linked below will get you set up with the Radio Configuration Utility and how to program the radio.","title":"Installing the FRC Radio Configuration Utility"},{"location":"setup/install_software.html#installing-the-radio-configuration-utility-and-programming-the-radio","text":"For Windows ONLY: Official FRC Radio Configuration Utility and Use guide (Windows only)","title":"Installing the Radio Configuration Utility and Programming the Radio"},{"location":"version_control/github.html","text":"[WIP] Using GitHub # This page is currently a work in progress. Check back later","title":"[WIP] Using GitHub"},{"location":"version_control/github.html#wip-using-github","text":"This page is currently a work in progress. Check back later","title":"[WIP] Using GitHub"}]}